# üìñ M√≥dulo 3 | Javascript

---

##  Unidad 1: Fundamentos

Temas:

Or√≠genes de la programaci√≥n

Lenguajes de programaci√≥n

Herramientas de desarrollo

Debugging

Sintaxis general

Variables y tipos de valores

Condicionales

Operadores de comparaci√≥n y l√≥gicos

Estructura de control

Propiedades de JavaScript

Sentencia break/continue y otras estructuras de control

Bucles

---
---

## :star:  Estructuras de Control

### Sintaxis general 

La sintaxis de un lenguaje de programaci√≥n se define como el conjunto de reglas que  deben seguirse al escribir el c√≥digo fuente de los programas para considerarse como  correctos para ese lenguaje de programaci√≥n. 

La sintaxis de JavaScript es muy similar a la de otros lenguajes de programaci√≥n como Java  y C. Las normas b√°sicas que definen la sintaxis de JavaScript son las siguientes: 

- **No se tienen en cuenta los espacios en blanco y las nuevas l√≠neas**: como sucede  con XHTML, el int√©rprete de JavaScript ignora cualquier espacio en blanco  sobrante, por lo que el c√≥digo se puede ordenar de forma adecuada para  entenderlo mejor (tabulando las l√≠neas, a√±adiendo espacios, creando nuevas  l√≠neas, etc.) 


- **Se distinguen las may√∫sculas y min√∫sculas**: al igual que sucede con la sintaxis de  las etiquetas y elementos XHTML. Sin embargo, si en una p√°gina XHTML se utilizan  indistintamente may√∫sculas y min√∫sculas, la p√°gina se visualiza correctamente,  siendo el √∫nico problema la no validaci√≥n de la p√°gina. En cambio, si en JavaScript  se intercambian may√∫sculas y min√∫sculas el script no funciona. 


- **No se define el tipo de las variables**: al crear una variable, no es necesario indicar  el tipo de dato que almacenar√°. De esta forma, una misma variable puede  almacenar diferentes tipos de datos durante la ejecuci√≥n del script. 


- **No es necesario terminar cada sentencia con el car√°cter de punto y coma (;)**: en  la mayor√≠a de lenguajes de programaci√≥n, es obligatorio terminar cada sentencia  con el car√°cter ;. Aunque JavaScript no obliga a hacerlo, es conveniente seguir la  tradici√≥n de terminar cada sentencia con el car√°cter del punto y coma (;). 


- **Se pueden incluir comentarios**: los comentarios se utilizan para a√±adir  informaci√≥n en el c√≥digo fuente del programa. Aunque el contenido de los  comentarios no se visualiza por pantalla, si que se env√≠a al navegador del usuario  junto con el resto del script, por lo que es necesario extremar las precauciones  sobre la informaci√≥n incluida en los comentarios.



### Variables 

Las variables en los lenguajes de programaci√≥n siguen una l√≥gica similar a las variables  utilizadas en otros √°mbitos como las matem√°ticas. Una variable es un elemento que se  emplea para almacenar y hacer referencia a otro valor. Gracias a las variables es posible  crear ‚Äúprogramas gen√©ricos‚Äù, es decir, programas que funcionan siempre igual  independientemente de los valores concretos utilizados. 

De la misma forma que si en Matem√°ticas no existieran las variables no se podr√≠an definir  las ecuaciones y f√≥rmulas, en programaci√≥n no se podr√≠an hacer programas realmente  √∫tiles sin las variables. 

Si no existieran variables, un programa que suma dos n√∫meros podr√≠a escribirse como: resultado = 3 + 1 

El programa anterior es tan poco √∫til que s√≥lo sirve para el caso en el que el primer  n√∫mero de la suma sea el 3 y el segundo n√∫mero sea el 1. En cualquier otro caso,  el programa obtiene un resultado incorrecto. 

Sin embargo, el programa se puede rehacer de la siguiente manera utilizando variables  para almacenar y referirse a cada n√∫mero: 

```JavaScript
numero_1 = 3 
numero_2 = 1 
resultado = numero_1 + numero_2 
```

Los elementos **numero_1** y **numero_2** son variables que almacenan los valores que utiliza  el programa. 

El resultado se calcula siempre en funci√≥n del valor almacenado por las  variables, por lo que este programa funciona correctamente para cualquier par de  n√∫meros indicado. 

Si se modifica el valor de las variables numero_1 y numero_2, el  programa sigue funcionando correctamente.

Las variables en JavaScript se crean mediante la palabra reservada var. De esta forma, el  ejemplo anterior se puede realizar en JavaScript de la siguiente manera: 

```JavaScript
var numero_1 = 3; 
var numero_2 = 1; 
var resultado = numero_1 + numero_2; 
```

La palabra reservada **var** solamente se debe indicar al definir por primera vez la variable,  lo que se denomina declarar una variable. Cuando se utilizan las variables en el resto de  instrucciones del script, solamente es necesario indicar su nombre. En otras palabras, en  el ejemplo anterior ser√≠a un error indicar lo siguiente: 

var numero_1 = 3; 

var numero_2 = 1; 

var resultado = var numero_1 + var numero_2; 

Si cuando se declara una variable se le asigna tambi√©n un valor, se dice que la variable ha  sido inicializada. En JavaScript no es obligatorio inicializar las variables, ya que se pueden  declarar por una parte y asignarles un valor posteriormente. Por tanto, el ejemplo anterior  se puede rehacer de la siguiente manera: 


```JavaScript
var numero_1; 
var numero_2; 
numero_1 = 3; 
numero_2 = 1; 
var resultado = numero_1 + numero_2;
```



Una de las caracter√≠sticas m√°s sorprendentes de JavaSript para los programadores  habituados a otros lenguajes de programaci√≥n es que tampoco es necesario declarar las  variables. En otras palabras, se pueden utilizar variables que no se han definido  anteriormente mediante la palabra reservada var. El ejemplo anterior tambi√©n es correcto  en JavaScript de la siguiente forma: 


```JavaScript
var numero_1 = 3; 
var numero_2 = 1; 
resultado = numero_1 + numero_2; 
```


La variable resultado no est√° declarada, por lo que JavaScript crea una variable global  (m√°s adelante se ver√°n las diferencias entre variables locales y globales) y le asigna el  valor correspondiente. De la misma forma, tambi√©n ser√≠a correcto el siguiente c√≥digo: 


```JavaScript
numero_1 = 3; 
numero_2 = 1; 
resultado = numero_1 + numero_2; 
```

En cualquier caso, se recomienda declarar todas las variables que se vayan a utilizar.

El nombre de una variable tambi√©n se conoce como identificador y debe cumplir las  siguientes normas: 

- S√≥lo puede estar formado por letras, n√∫meros y los s√≠mbolos $ (d√≥lar) y _ (gui√≥n bajo). 

- El primer car√°cter no puede ser un n√∫mero. 


Por tanto, las siguientes variables tienen nombres correctos: 

```JavaScript
var $numero1; 
var _$letra; 
var $$$otroNumero; 
var $_a__$4; 
```

Sin embargo, las siguientes variables tienen identificadores incorrectos: 

```JavaScript
var 1numero; // Empieza por un n√∫mero 
var numero;1_123; // Contiene un car√°cter ‚Äú;‚Äù
```


### Tipos de Valores 

Aunque todas las variables de JavaScript se crean de la misma forma (mediante la palabra  reservada var), la forma en la que se les asigna un valor depende del tipo de valor que se  quiere almacenar (n√∫meros, textos, etc.) 

#### Num√©ricos (Integers) 

Se utilizan para almacenar valores num√©ricos enteros (llamados **integer** en ingl√©s) o  decimales (llamados **float** en ingl√©s). 

En este caso, el valor se asigna indicando  directamente el n√∫mero entero o decimal. 

Los n√∫meros decimales utilizan el  car√°cter . (punto) en vez de , (coma) para separar la parte entera y la parte decimal: 


```JavaScript
var iva = 16; // variable tipo entero 
var total = 234.65; // variable tipo decimal 
```


#### Cadenas de texto (Strings) 

Se utilizan para almacenar caracteres, palabras y/o frases de texto. Para asignar el valor a  la variable, se encierra el valor entre comillas dobles o simples, para delimitar su comienzo  y su final: 


```JavaScript
var mensaje = ‚ÄúBienvenido a Academia Numen‚Äù; 
var nombreCurso = ‚ÄòDesarrollo Web Full Stack‚Äô; 
var letraSeleccionada = ‚ÄòA‚Äô;
```


En ocasiones, el texto que se almacena en las variables no es tan sencillo. Si por ejemplo el  propio texto contiene comillas simples o dobles, la estrategia que se sigue es la de  encerrar el texto con las comillas (simples o dobles) que no utilice el texto: 


```JavaScript
// El contenido de texto1 tiene comillas simples, por lo que se encierra con comillas dobles  
var texto1 = ‚ÄúUna frase con ‚Äòcomillas simples‚Äô dentro‚Äù; 

// El contenido de texto2 tiene comillas dobles, por lo que se encierra con comillas simples  
var texto2 = ‚ÄòUna frase con ‚Äúcomillas dobles‚Äù dentro‚Äô; 
```


No obstante, a veces las cadenas de texto contienen tanto comillas simples como dobles.  

Adem√°s, existen otros caracteres que son dif√≠ciles de incluir en una variable de texto  (tabulador, ENTER, etc.) Para resolver estos problemas, JavaScript define un mecanismo  para incluir de forma sencilla caracteres especiales y problem√°ticos dentro de una cadena  de texto. 

El mecanismo consiste en sustituir el car√°cter problem√°tico por una combinaci√≥n simple  de caracteres. A continuaci√≥n se muestra la tabla de conversi√≥n que se debe utilizar:


| Si se quiere incluir‚Ä¶ | Se debe incluir‚Ä¶ |
| --------------------- | ---------------- |
| Una nueva l√≠nea | 	```\n``` |
| Un tabulador 	| ```\t``` |
| Una comilla simple |	```\‚Äô``` |
| Una comilla doble  |	```\‚Äù``` |
|Una barra inclinada 	| ```\\``` |
 

De esta forma, el ejemplo anterior que conten√≠a comillas simples y dobles dentro del texto  se puede rehacer de la siguiente forma: 


```JavaScript
var texto1 = ‚ÄòUna frase con \‚Äôcomillas simples\‚Äô dentro‚Äô; 
var texto2 = ‚ÄúUna frase con \‚Äùcomillas dobles\‚Äù dentro‚Äù; 
```


Este mecanismo de JavaScript se denomina ‚Äúmecanismo de escape‚Äù de los caracteres  problem√°ticos, y es habitual referirse a que los caracteres han sido ‚Äúescapados‚Äù. 


#### Arrays 

En ocasiones, a los arrays se les llama vectores, matrices e incluso arreglos. No obstante,  el t√©rmino array es el m√°s utilizado y es una palabra com√∫nmente aceptada en el entorno  de la programaci√≥n. 

Un array es una colecci√≥n de variables, que pueden ser todas del mismo tipo o cada una  de un tipo diferente. Su utilidad se comprende mejor con un ejemplo sencillo: si una  aplicaci√≥n necesita manejar los d√≠as de la semana, se podr√≠an crear siete variables de tipo  texto: 


```JavaScripr
var dia1 = ‚ÄúLunes‚Äù; 
var dia2 = ‚ÄúMartes‚Äù; 
var dia7 = ‚ÄúDomingo‚Äù; 
```


Aunque el c√≥digo anterior no es incorrecto, s√≠ que es poco eficiente y complica en exceso  la programaci√≥n. Si en vez de los d√≠as de la semana se tuviera que guardar el nombre de  los meses del a√±o, el nombre de todos los pa√≠ses del mundo o las mediciones diarias de  temperatura de los √∫ltimos 100 a√±os, se tendr√≠an que crear decenas o cientos de  variables.

En este tipo de casos, se pueden agrupar todas las variables relacionadas en una colecci√≥n  de variables o array. El ejemplo anterior se puede rehacer de la siguiente forma: 

```var dias = [‚ÄúLunes‚Äù, ‚ÄúMartes‚Äù, ‚ÄúMi√©rcoles‚Äù, ‚ÄúJueves‚Äù, ‚ÄúViernes‚Äù, ‚ÄúS√°bado‚Äù, ‚ÄúDomingo‚Äù]; ```

Ahora, una √∫nica variable llamada dias almacena todos los valores relacionados entre s√≠,  en este caso los d√≠as de la semana. Para definir un array, se utilizan los caracteres [ y ] para  delimitar su comienzo y su final y se utiliza el car√°cter , (coma) para separar sus  elementos: 

```var nombre_array = [valor1, valor2, ‚Ä¶, valorN]; ```

Una vez definido un array, es muy sencillo acceder a cada uno de sus elementos. Cada  elemento se accede indicando su posici√≥n dentro del array. La √∫nica complicaci√≥n, que es  responsable de muchos errores cuando se empieza a programar, es que las posiciones de  los elementos empiezan a contarse en el 0 y no en el 1: 

```var diaSeleccionado = dias[0]; // diaSeleccionado = ‚ÄúLunes‚Äù ```

```var otroDia = dias[5]; // otroDia = ‚ÄúS√°bado‚Äù ```

En el ejemplo anterior, la primera instrucci√≥n quiere obtener el primer elemento del  array. Para ello, se indica el nombre del array y entre corchetes la posici√≥n del elemento  dentro del array. Como se ha comentado, las posiciones se empiezan a contar en el 0, por  lo que el primer elemento ocupa la posici√≥n 0 y se accede a el mediante dias[0]. 

El valor dias[5] hace referencia al elemento que ocupa la sexta posici√≥n dentro del  array dias. Como las posiciones empiezan a contarse en 0, la posici√≥n 5 hace referencia al  sexto elemento, en este caso, el valor S√°bado.


### Booleanos 

Las variables de tipo boolean o booleano tambi√©n se conocen con el nombre de variables  de tipo l√≥gico. Su funcionamiento b√°sico es muy sencillo. 

Una variable de tipo boolean almacena un tipo especial de valor que solamente puede  tomar dos valores: true (verdadero) o false (falso). No se puede utilizar para almacenar  n√∫meros y tampoco permite guardar cadenas de texto. 

Los √∫nicos valores que pueden almacenar estas variables son true y false, por lo que no  pueden utilizarse los valores verdadero y falso. A continuaci√≥n se muestra un par de  variables de tipo booleano: 


```JavaScript
var clienteRegistrado = false; 
var ivaIncluido = true;
```


#### Operadores 

Las variables por s√≠ solas son de poca utilidad. Hasta ahora, s√≥lo se ha visto c√≥mo crear  variables de diferentes tipos y c√≥mo mostrar su valor mediante la funci√≥n alert(). Para  hacer programas realmente √∫tiles, son necesarias otro tipo de herramientas. 

Los operadores permiten manipular el valor de las variables, realizar operaciones matem√°ticas con sus valores y comparar diferentes variables. De esta forma, los  operadores permiten a los programas realizar c√°lculos complejos y tomar decisiones  l√≥gicas en funci√≥n de comparaciones y otros tipos de condiciones. 

#### Incremento y Decremento 

Estos dos operadores solamente son v√°lidos para las variables num√©ricas y se utilizan para  incrementar o decrementar en una unidad el valor de una variable. 

Ejemplo: 

```JavaScript
var numero = 5; 
++numero; 
alert(numero); // numero = 6 
```


El operador de incremento se indica mediante el prefijo ++ en el nombre de la variable. El  resultado es que el valor de esa variable se incrementa en una unidad. Por tanto, el  anterior ejemplo es equivalente a: 


```JavaScript
var numero = 5; 
numero = numero + 1; 
alert(numero); // numero = 6
```


De forma equivalente, el operador decremento (indicado como un prefijo ‚Äî en el nombre  de la variable) se utiliza para decrementar el valor de la variable: 


```JavaScript
var numero = 5; 
‚Äînumero; 
alert(numero); // numero = 4 
```


El anterior ejemplo es equivalente a: 

```JavaScript
var numero = 5; 
numero = numero ‚Äì 1; 
alert(numero); // numero = 4 
```


Los operadores de incremento y decremento no solamente se pueden indicar como  prefijo del nombre de la variable, sino que tambi√©n es posible utilizarlos como sufijo. En  este caso, su comportamiento es similar pero muy diferente. En el siguiente ejemplo: 


```JavaScript
var numero = 5; 
numero++; 
alert(numero); // numero = 6 
```


El resultado de ejecutar el script anterior es el mismo que cuando se utiliza el  operador ++numero, por lo que puede parecer que es equivalente indicar el  operador ++ delante o detr√°s del identificador de la variable. 

Sin embargo, el siguiente ejemplo muestra sus diferencias: 


```JavaScript
var numero1 = 5; 
var numero2 = 2; 
numero3 = numero1++ + numero2; 
// numero3 = 7, numero1 = 6 
var numero1 = 5; 
var numero2 = 2; 
numero3 = ++numero1 + numero2; 
// numero3 = 8, numero1 = 6 
```



Si el operador ++ se indica como prefijo del identificador de la variable, su valor se  incrementa antes de realizar cualquier otra operaci√≥n. Si el operador ++ se indica como  sufijo del identificador de la variable, su valor se incrementa despu√©s de ejecutar la  sentencia en la que aparece. 

Por tanto, en la instrucci√≥n numero3 = numero1++ + numero2;, el valor de numero1 se  incrementa despu√©s de realizar la operaci√≥n (primero se suma y numero3 vale 7, despu√©s  se incrementa el valor de numero1 y vale 6). Sin embargo, en la instrucci√≥n numero3 =  ++numero1 + numero2;, en primer lugar se incrementa el valor de numero1 y despu√©s se  realiza la suma (primero se incrementa numero1 y vale 6, despu√©s se realiza la suma  y numero3 vale 8).


#### Negaci√≥n (!) 

Uno de los operadores l√≥gicos m√°s utilizados es el de la negaci√≥n. Se utiliza para obtener  el valor contrario al valor de la variable: 


```JavaScript
var visible = true; 
alert(!visible); // Muestra ‚Äúfalse‚Äù y no ‚Äútrue‚Äù 
```


La negaci√≥n l√≥gica se obtiene prefijando el s√≠mbolo ! al identificador de la variable. El  funcionamiento de este operador se resume en la siguiente tabla: 

| variable |	!variable |
| -------- | ------------ |
| true |	false |
| false 	| true |
 

Si la variable original es de tipo booleano, es muy sencillo obtener su negaci√≥n. Sin  embargo, ¬øqu√© sucede cuando la variable es un n√∫mero o una cadena de texto? Para  obtener la negaci√≥n en este tipo de variables, se realiza en primer lugar su conversi√≥n a un  valor booleano: 

- Si la variable contiene un n√∫mero, se transforma en false si vale 0 y en true para  cualquier otro n√∫mero (positivo o negativo, decimal o entero). 

- Si la variable contiene una cadena de texto, se transforma en false si la cadena es  vac√≠a (‚Äú‚Äù) y en true en cualquier otro caso. 


```JavaScript
var cantidad = 0; 
vacio = !cantidad; // vacio = true 
cantidad = 2; 
vacio = !cantidad; // vacio = false
var mensaje = ‚Äú‚Äù; 
mensajeVacio = !mensaje; // mensajeVacio = true 
mensaje = ‚ÄúBienvenido‚Äù; 
mensajeVacio = !mensaje; // mensajeVacio = false 
```


# ### AND (&&) 

La operaci√≥n l√≥gica AND obtiene su resultado combinando dos valores booleanos. El  operador se indica mediante el s√≠mbolo && y su resultado solamente es true si los dos  operandos son true: 


```
variable1    variable2 	variable1 && variable2
true 	       true 	  true
true 	       false 	  false
false 	       true 	  false
false 	       false 	  false
``` 

```JavaScript
var valor1 = true; 
var valor2 = false; 
resultado = valor1 && valor2; // resultado = false 
valor1 = true; 
valor2 = true; 
resultado = valor1 && valor2; // resultado = true
```


#### OR (||) 

La operaci√≥n l√≥gica OR tambi√©n combina dos valores booleanos. El operador se indica  mediante el s√≠mbolo || y su resultado es true si alguno de los dos operandos es true: 


```
variable1  variable2 	variable1 || variable2
true 	   true 	 true
true 	   false 	 true
false 	   true 	 true
false 	   false 	 false
```


```JavaScript 
var valor1 = true; 
var valor2 = false; 
resultado = valor1 || valor2; // resultado = true 
valor1 = false; 
valor2 = false; 
resultado = valor1 || valor2; // resultado = false
```


#### Matem√°ticos 

JavaScript permite realizar manipulaciones matem√°ticas sobre el valor de las variables  num√©ricas. Los operadores definidos son: suma (```+```), resta (```‚Äì```), multiplicaci√≥n (```*```) y divisi√≥n  (```/```). Ejemplo: 


```JavaScript
var numero1 = 10; 
var numero2 = 5; 
resultado = numero1 / numero2; // resultado = 2 
resultado = 3 + numero1; // resultado = 13 
resultado = numero2 ‚Äì 4; // resultado = 1 
resultado = numero1 * numero 2; // resultado = 50 
```


Adem√°s de los cuatro operadores b√°sicos, JavaScript define otro operador matem√°tico  que no es sencillo de entender cuando se estudia por primera vez, pero que es muy √∫til en  algunas ocasiones. 

Se trata del operador ‚Äúm√≥dulo‚Äù, que calcula el resto de la divisi√≥n entera de dos n√∫meros.  Si se divide por ejemplo 10 y 5, la divisi√≥n es exacta y da un resultado de 2. El resto de esa  divisi√≥n es 0, por lo que m√≥dulo de 10 y 5 es igual a 0. 

Sin embargo, si se divide 9 y 5, la divisi√≥n no es exacta, el resultado es 1 y el resto 4, por lo  que m√≥dulo de 9 y 5 es igual a 4. 

El operador m√≥dulo en JavaScript se indica mediante el s√≠mbolo %, que no debe  confundirse con el c√°lculo del porcentaje: 


```JavaScript
var numero1 = 10; 
var numero2 = 5; 
resultado = numero1 % numero2; // resultado = 0
numero1 = 9; 
numero2 = 5; 
resultado = numero1 % numero2; // resultado = 4 
```


Los operadores matem√°ticos tambi√©n se pueden combinar con el operador de asignaci√≥n  para abreviar su notaci√≥n: 


```JavaScript
var numero1 = 5; 
numero1 += 3; // numero1 = numero1 + 3 = 8 
numero1 -= 1; // numero1 = numero1 ‚Äì 1 = 4 
numero1 *= 2; // numero1 = numero1 * 2 = 10 
numero1 /= 5; // numero1 = numero1 / 5 = 1 
numero1 %= 4; // numero1 = numero1 % 4 = 1
```


#### Relacionales 

Los operadores relacionales definidos por JavaScript son id√©nticos a los que definen las  matem√°ticas: mayor que (```>```), menor que (```<```), mayor o igual (```>=```), menor o igual (```<=```), igual  que (```==```) y distinto de (```!=```). 

Los operadores que relacionan variables son imprescindibles para realizar cualquier  aplicaci√≥n compleja, como se ver√° en el siguiente cap√≠tulo de programaci√≥n avanzada. El  resultado de todos estos operadores siempre es un valor booleano: 


```JavaScript
var numero1 = 3; 
var numero2 = 5; 
resultado = numero1 > numero2; // resultado = false 
resultado = numero1 < numero2; // resultado = true 
numero1 = 5; 
numero2 = 5; 
resultado = numero1 >= numero2; // resultado = true 
resultado = numero1 <= numero2; // resultado = true 
resultado = numero1 == numero2; // resultado = true 
resultado = numero1 != numero2; // resultado = false
```

Se debe tener especial cuidado con el operador de igualdad (==), ya que es el origen de la  mayor√≠a de errores de programaci√≥n, incluso para los usuarios que ya tienen cierta  experiencia desarrollando scripts. El operador == se utiliza para comparar el valor de dos  variables, por lo que es muy diferente del operador =, que se utiliza para asignar un valor a  una variable: 

```// El operador ‚Äú=‚Äù asigna valores ```

```JavaScript
var numero1 = 5; 
resultado = numero1 = 3; // numero1 = 3 y resultado = 3 
```


```// El operador ‚Äú==‚Äù compara variables ```


```JavaScript
var numero1 = 5; 
resultado = numero1 == 3; // numero1 = 5 y resultado = false 
```


Los operadores relacionales tambi√©n se pueden utilizar con variables de tipo cadena de  texto: 

```JavaScript
var texto1 = ‚Äúhola‚Äù; 
var texto2 = ‚Äúhola‚Äù; 
var texto3 = ‚Äúadios‚Äù;
resultado = texto1 == texto3; // resultado = false 
resultado = texto1 != texto2; // resultado = false 
resultado = texto3 >= texto2; // resultado = false 
```

Cuando se utilizan cadenas de texto, los operadores ‚Äúmayor que‚Äù (```>```) y ‚Äúmenor que‚Äù (```<```)  siguen un razonamiento no intuitivo: se compara letra a letra comenzando desde la  izquierda hasta que se encuentre una diferencia entre las dos cadenas de texto. Para  determinar si una letra es mayor o menor que otra, las may√∫sculas se consideran menores  que las min√∫sculas y las primeras letras del alfabeto son menores que las √∫ltimas (a es  menor que b, b es menor que c, A es menor que a, etc.)


#### Condicionales y Estructuras de Control 

Los programas que se pueden realizar utilizando solamente variables y operadores son  una simple sucesi√≥n lineal de instrucciones b√°sicas. 

Sin embargo, no se pueden realizar programas que muestren un mensaje si el valor de una  variable es igual a un valor determinado y no muestren el mensaje en el resto de casos.  Tampoco se puede repetir de forma eficiente una misma instrucci√≥n, como por ejemplo  sumar un determinado valor a todos los elementos de un array. 

Para realizar este tipo de programas son necesarias las estructuras de control de flujo,  que son instrucciones del tipo ‚Äúsi se cumple esta condici√≥n, hazlo; si no se cumple, haz esto  otro‚Äù. Tambi√©n existen instrucciones del tipo ‚Äúrepite esto mientras se cumpla esta  condici√≥n‚Äù. 

Si se utilizan estructuras de control de flujo, los programas dejan de ser una sucesi√≥n  lineal de instrucciones para convertirse en programas inteligentes que pueden tomar  decisiones en funci√≥n del valor de las variables. 

Estructura If 

La estructura m√°s utilizada en JavaScript y en la mayor√≠a de lenguajes de programaci√≥n es  la estructura if. Se emplea para tomar decisiones en funci√≥n de una condici√≥n. Su  definici√≥n formal es: 

```
if(condicion) { 
 ‚Ä¶ 
} 
```

Si la condici√≥n se cumple (es decir, si su valor es true) se ejecutan todas las instrucciones  que se encuentran dentro de {‚Ä¶}. Si la condici√≥n no se cumple (es decir, si su valor  es false) no se ejecuta ninguna instrucci√≥n contenida en {‚Ä¶} y el programa contin√∫a  ejecutando el resto de instrucciones del script. 

Ejemplo: 


```JavaScript
var mostrarMensaje = true;

if(mostrarMensaje) { 
 alert(‚ÄúHola Mundo‚Äù); 
} 
```

En el ejemplo anterior, el mensaje s√≠ que se muestra al usuario ya que la  variable mostrarMensaje tiene un valor de true y por tanto, el programa entra dentro del  bloque de instrucciones del if. 

El ejemplo se podr√≠a reescribir tambi√©n como: 


```JavaScript
var mostrarMensaje = true; 

if(mostrarMensaje == true) { 
 alert(‚ÄúHola Mundo‚Äù); 
} 
```

En este caso, la condici√≥n es una comparaci√≥n entre el valor de la  

variable mostrarMensaje y el valor true. Como los dos valores coinciden, la igualdad se  cumple y por tanto la condici√≥n es cierta, su valor es true y se ejecutan las instrucciones  contenidas en ese bloque del if.

La comparaci√≥n del ejemplo anterior suele ser el origen de muchos errores de  programaci√≥n, al confundir los operadores == y =. Las comparaciones siempre se realizan  con el operador ==, ya que el operador = solamente asigna valores: 


```
var mostrarMensaje = true; 

// Se comparan los dos valores 

if(mostrarMensaje == false) { 
 ‚Ä¶ 
} 
```


```
// Error ‚Äì Se asigna el valor ‚Äúfalse‚Äù a la variable 

if(mostrarMensaje = false) { 
 ‚Ä¶ 
} 
```

La condici√≥n que controla el if() puede combinar los diferentes operadores l√≥gicos y  relacionales mostrados anteriormente: 

```
var mostrado = false;

if(!mostrado) { 
 alert(‚ÄúEs la primera vez que se muestra el mensaje‚Äù); 
} 
```

Los operadores AND y OR permiten encadenar varias condiciones simples para construir  condiciones complejas: 


```JavaScript
var mostrado = false; 

var usuarioPermiteMensajes = true; 

if(!mostrado && usuarioPermiteMensajes) { 
 alert(‚ÄúEs la primera vez que se muestra el mensaje‚Äù); 
} 
```

La condici√≥n anterior est√° formada por una operaci√≥n AND sobre dos variables. A su vez, a  la primera variable se le aplica el operador de negaci√≥n antes de realizar la  operaci√≥n AND. De esta forma, como el valor de mostrado es false, el  valor !mostrado ser√≠a true. Como la variable usuarioPermiteMensajes vale true, el  resultado de !mostrado && usuarioPermiteMensajes ser√≠a igual a true && true, por lo que  el resultado final de la condici√≥n del if() ser√≠a true y por tanto, se ejecutan las  instrucciones que se encuentran dentro del bloque del if().

#### Estructura If ‚Ä¶ else 

En ocasiones, las decisiones que se deben realizar no son del tipo ‚Äúsi se cumple la  condici√≥n, hazlo; si no se cumple, no hagas nada‚Äù. Normalmente las condiciones suelen  ser del tipo ‚Äúsi se cumple esta condici√≥n, hazlo; si no se cumple, haz esto otro‚Äù. 

Para este segundo tipo de decisiones, existe una variante de la  

estructura if llamada if‚Ä¶else. Su definici√≥n formal es la siguiente: 


```
if(condicion) { 
 ‚Ä¶ 
} else { 
 ‚Ä¶ 
} 
```


Si la condici√≥n se cumple (es decir, si su valor es true) se ejecutan todas las instrucciones  que se encuentran dentro del if(). Si la condici√≥n no se cumple (es decir, si su valor  es false) se ejecutan todas las instrucciones contenidas en else { }. 

Ejemplo: 


```JavaScript
var edad = 18;

if(edad >= 18) { 
 alert(‚ÄúEres mayor de edad‚Äù); 
} else { 
 alert(‚ÄúTodav√≠a eres menor de edad‚Äù); 
} 
```

Si el valor de la variable edad es mayor o igual que el valor num√©rico 18, la condici√≥n del if() se cumple y por tanto, se ejecutan sus instrucciones y se muestra el mensaje ‚ÄúEres  mayor de edad‚Äù. Sin embargo, cuando el valor de la variable edad no es igual o mayor  que 18, la condici√≥n del if() no se cumple, por lo que autom√°ticamente se ejecutan todas  las instrucciones del bloque else { }. En este caso, se mostrar√≠a el mensaje ‚ÄúTodav√≠a eres  menor de edad‚Äù. 

El siguiente ejemplo compara variables de tipo cadena de texto: 


```JavaScript
var nombre = ‚Äú‚Äù; 

if(nombre == ‚Äú‚Äù) { 
 alert(‚ÄúA√∫n no nos has dicho tu nombre‚Äù); 
} else { 
 alert(‚ÄúHemos guardado tu nombre‚Äù); 
}
```



La condici√≥n del if() anterior se construye mediante el operador ==, que es el que se  emplea para comparar dos valores (no confundir con el operador = que se utiliza para  asignar valores). En el ejemplo anterior, si la cadena de texto almacenada en la  variable nombre es vac√≠a (es decir, es igual a ‚Äú‚Äù) se muestra el mensaje definido en el if().  En otro caso, se muestra el mensaje definido en el bloque else { }. 

La estructura if‚Ä¶else se puede encadenar para realizar varias comprobaciones seguidas: 

```
if(edad < 12) { 
 alert(‚ÄúTodav√≠a eres muy peque√±o‚Äù); 
}  else if(edad < 19) { 
 alert(‚ÄúEres un adolescente‚Äù); 
} else if(edad < 35) { 
 alert(‚ÄúAun sigues siendo joven‚Äù); 
} else { 
 alert(‚ÄúPiensa en cuidarte un poco m√°s‚Äù); 
} 
```

No es obligatorio que la combinaci√≥n de estructuras if‚Ä¶else acabe con la instrucci√≥n else,  ya que puede terminar con una instrucci√≥n de tipo else if().

#### Estructura for 

Las estructuras if y if‚Ä¶else no son muy eficientes cuando se desea ejecutar de forma  repetitiva una instrucci√≥n. Por ejemplo, si se quiere mostrar un mensaje cinco veces, se  podr√≠a pensar en utilizar el siguiente if: 


```JavaScript
var veces = 0; 

if(veces < 4) { 
 alert(‚ÄúMensaje‚Äù); 
 veces++; 
} 
```

Se comprueba si la variable veces es menor que 4. Si se cumple, se entra dentro del if(), se  muestra el mensaje y se incrementa el valor de la variable veces. As√≠ se deber√≠a seguir  ejecutando hasta mostrar el mensaje las cinco veces deseadas. 

Sin embargo, el funcionamiento real del script anterior es muy diferente al deseado, ya  que solamente se muestra una vez el mensaje por pantalla. La raz√≥n es que la ejecuci√≥n  de la estructura if() no se repite y la comprobaci√≥n de la condici√≥n s√≥lo se realiza una vez,  independientemente de que dentro del if() se modifique el valor de la variable utilizada en  la condici√≥n. 

La estructura for permite realizar este tipo de repeticiones (tambi√©n llamadas bucles) de  una forma muy sencilla. No obstante, su definici√≥n formal no es tan sencilla como la  de if(): 

```
for(inicializacion; condicion; actualizacion) { 
 ‚Ä¶ 
}
```

La idea del funcionamiento de un bucle for es la siguiente: ‚Äúmientras la condici√≥n indicada  se siga cumpliendo, repite la ejecuci√≥n de las instrucciones definidas dentro del for.  Adem√°s, despu√©s de cada repetici√≥n, actualiza el valor de las variables que se utilizan en la  condici√≥n‚Äù. 


- La ‚Äúinicializaci√≥n‚Äù es la zona en la que se establece los valores iniciales de las  variables que controlan la repetici√≥n. 

- La ‚Äúcondici√≥n‚Äù es el √∫nico elemento que decide si continua o se detiene la  repetici√≥n. 

- La ‚Äúactualizaci√≥n‚Äù es el nuevo valor que se asigna despu√©s de cada repetici√≥n a las  variables que controlan la repetici√≥n. 


```JavaScript
var mensaje = ‚ÄúHola, estoy dentro de un bucle‚Äù; 

for(var i = 0; i < 5; i++) { 
 alert(mensaje); 
} 
```

La parte de la inicializaci√≥n del bucle consiste en: 

```var i = 0;``` 

Por tanto, en primer lugar se crea la variable i y se le asigna el valor de 0. Esta zona de  inicializaci√≥n solamente se tiene en consideraci√≥n justo antes de comenzar a ejecutar el  bucle. Las siguientes repeticiones no tienen en cuenta esta parte de inicializaci√≥n. 

La zona de condici√≥n del bucle es: 

```i < 5``` 

Los bucles se siguen ejecutando mientras se cumplan las condiciones y se dejan de  ejecutar justo despu√©s de comprobar que la condici√≥n no se cumple. En este caso,  mientras la variable i valga menos de 5 el bucle se ejecuta indefinidamente.

Como la variable i se ha inicializado a un valor de 0 y la condici√≥n para salir del bucle es  que i sea menor que 5, si no se modifica el valor de i de alguna forma, el bucle se repetir√≠a  indefinidamente. 

Por ese motivo, es imprescindible indicar la zona de actualizaci√≥n, en la que se modifica el  valor de las variables que controlan el bucle: 

```i++ ```

En este caso, el valor de la variable i se incrementa en una unidad despu√©s de cada  repetici√≥n. La zona de actualizaci√≥n se ejecuta despu√©s de la ejecuci√≥n de las instrucciones  que incluye el for. 

As√≠, durante la ejecuci√≥n de la quinta repetici√≥n el valor de i ser√° 4. Despu√©s de la quinta  ejecuci√≥n, se actualiza el valor de i, que ahora valdr√° 5. Como la condici√≥n es que i sea  menor que 5, la condici√≥n ya no se cumple y las instrucciones del for no se ejecutan una  sexta vez. 

Normalmente, la variable que controla los bucles for se llama i, ya que recuerda a la  palabra √≠ndice y su nombre tan corto ahorra mucho tiempo y espacio. 

El ejemplo anterior que mostraba los d√≠as de la semana contenidos en un array se puede  rehacer de forma m√°s sencilla utilizando la estructura for: 


```JavaScript
var dias = [‚ÄúLunes‚Äù, ‚ÄúMartes‚Äù, ‚ÄúMi√©rcoles‚Äù, ‚ÄúJueves‚Äù, ‚ÄúViernes‚Äù, ‚ÄúS√°bado‚Äù, ‚ÄúDomingo‚Äù]; 

for(var i=0; i<7; i++) { 
 alert(dias[i]); 
}
```


#### Estructura for ‚Ä¶ in 

Una estructura de control derivada de for es la estructura for‚Ä¶in. Su definici√≥n exacta  implica el uso de objetos, que es un elemento de programaci√≥n avanzada que no se va a  estudiar. Por tanto, solamente se va a presentar la estructura for‚Ä¶in adaptada a su uso en  arrays. Su definici√≥n formal adaptada a los arrays es: 


```
for(indice in array) { 
 ‚Ä¶ 
} 
```

Si se quieren recorrer todos los elementos que forman un array, la estructura for‚Ä¶in es la  forma m√°s eficiente de hacerlo, como se muestra en el siguiente ejemplo: 


```JavaScript
var dias = [‚ÄúLunes‚Äù, ‚ÄúMartes‚Äù, ‚ÄúMi√©rcoles‚Äù, ‚ÄúJueves‚Äù, ‚ÄúViernes‚Äù, ‚ÄúS√°bado‚Äù, ‚ÄúDomingo‚Äù]; 

for(i in dias) { 
 alert(dias[i]); 
} 
```

La variable que se indica como indice es la que se puede utilizar dentro del  bucle for‚Ä¶in para acceder a los elementos del array. De esta forma, en la primera  repetici√≥n del bucle la variable i vale 0 y en la √∫ltima vale 6. 

Esta estructura de control es la m√°s adecuada para recorrer arrays (y objetos), ya que  evita tener que indicar la inicializaci√≥n y las condiciones del bucle for simple y funciona  correctamente cualquiera que sea la longitud del array. De hecho, sigue funcionando igual  aunque var√≠e el n√∫mero de elementos del array.

#### Propiedades de JavaScript 

- JavaScript incorpora una serie de herramientas y utilidades para el manejo de las  variables. De esta forma, muchas de las operaciones b√°sicas con las variables, se pueden  realizar directamente con las utilidades que ofrece JavaScript. 

- Funciones √∫tiles para cadenas de Texto 

A continuaci√≥n se muestran algunas de las funciones m√°s √∫tiles para el manejo de  cadenas de texto: 

- **length**, calcula la longitud de una cadena de texto (el n√∫mero de caracteres que la forman) 

```JavaScript
var mensaje = ‚ÄúHola Mundo‚Äù; 
var numeroLetras = mensaje.length; // numeroLetras = 10 
```

- **+**, se emplea para concatenar varias cadenas de texto :

```JavaScript
var mensaje1 = ‚ÄúHola‚Äù; 
var mensaje2 = ‚Äù Mundo‚Äù; 
var mensaje = mensaje1 + mensaje2; // mensaje = ‚ÄúHola Mundo‚Äù 
```

Adem√°s del operador +, tambi√©n se puede utilizar la funci√≥n **concat()**:

```JavaScript
var mensaje1 = ‚ÄúHola‚Äù; 
var mensaje2 = mensaje1.concat(‚Äù Mundo‚Äù); // mensaje2 = ‚ÄúHola Mundo‚Äù
```

- Las cadenas de texto tambi√©n se pueden unir con variables num√©ricas: 

```JavaScript
var variable1 = ‚ÄúHola ‚Äú; 
var variable2 = 3; 
var mensaje = variable1 + variable2; // mensaje = ‚ÄúHola 3‚Äù 
```

- Cuando se unen varias cadenas de texto es habitual olvidar a√±adir un espacio de  separaci√≥n entre las palabras: 

```JavaScript
var mensaje1 = ‚ÄúHola‚Äù; 
var mensaje2 = ‚ÄúMundo‚Äù; 
var mensaje = mensaje1 + mensaje2; // mensaje = ‚ÄúHolaMundo‚Äù 
```

- Los espacios en blanco se pueden a√±adir al final o al principio de las cadenas y tambi√©n se  pueden indicar forma expl√≠cita: 

```JavaScript
var mensaje1 = ‚ÄúHola‚Äù; 
var mensaje2 = ‚ÄúMundo‚Äù; 
var mensaje = mensaje1 + ‚Äù ‚Äù + mensaje2; // mensaje = ‚ÄúHola Mundo‚Äù 
```

- **toUpperCase()**, transforma todos los caracteres de la cadena a sus correspondientes  caracteres en may√∫sculas: 


```JavaScript
var mensaje1 = ‚ÄúHola‚Äù; 
var mensaje2 = mensaje1.toUpperCase(); // mensaje2 = ‚ÄúHOLA‚Äù
```

- **toLowerCase()**, transforma todos los caracteres de la cadena a sus correspondientes  caracteres en min√∫sculas: 

```JavaScript
var mensaje1 = ‚ÄúHolA‚Äù; 
var mensaje2 = mensaje1.toLowerCase(); // mensaje2 = ‚Äúhola‚Äù 
```

- **charAt(posicion)**, obtiene el car√°cter que se encuentra en la posici√≥n indicada: var mensaje = ‚ÄúHola‚Äù; 

```JavaScript
var letra = mensaje.charAt(0); // letra = H 
letra = mensaje.charAt(2); // letra = l 
```

- **indexOf(caracter)**, calcula la posici√≥n en la que se encuentra el car√°cter indicado dentro de  la cadena de texto. Si el car√°cter se incluye varias veces dentro de la cadena de texto, se  devuelve su primera posici√≥n empezando a buscar desde la izquierda. Si la cadena no  contiene el car√°cter, la funci√≥n devuelve el valor -1: 

```JavaScript
var mensaje = ‚ÄúHola‚Äù; 
var posicion = mensaje.indexOf(‚Äòa‚Äô); // posicion = 3 
posicion = mensaje.indexOf(‚Äòb‚Äô); // posicion = -1 
```

Su funci√≥n an√°loga es **lastIndexOf()**: 

- **lastIndexOf(caracter)**, calcula la √∫ltima posici√≥n en la que se encuentra el car√°cter  indicado dentro de la cadena de texto. Si la cadena no contiene el car√°cter, la funci√≥n  devuelve el valor -1: 


```JavaScript
var mensaje = ‚ÄúHola‚Äù; 
var posicion = mensaje.lastIndexOf(‚Äòa‚Äô); // posicion = 3 
posicion = mensaje.lastIndexOf(‚Äòb‚Äô); // posicion = -1
```

La funci√≥n lastIndexOf() comienza su b√∫squeda desde el final de la cadena hacia el  principio, aunque la posici√≥n devuelta es la correcta empezando a contar desde el  principio de la palabra. 

- **substring(inicio, final)**, extrae una porci√≥n de una cadena de texto. El segundo par√°metro  es opcional. Si s√≥lo se indica el par√°metro inicio, la funci√≥n devuelve la parte de la cadena  original correspondiente desde esa posici√≥n hasta el final: 


```JavaScript
var mensaje = ‚ÄúHola Mundo‚Äù; 
var porcion = mensaje.substring(2); // porcion = ‚Äúla Mundo‚Äù 
porcion = mensaje.substring(5); // porcion = ‚ÄúMundo‚Äù 
porcion = mensaje.substring(7); // porcion = ‚Äúndo‚Äù 
```

Si se indica un inicio negativo, se devuelve la misma cadena original: 

```JavaScript
var mensaje = ‚ÄúHola Mundo‚Äù; 
var porcion = mensaje.substring(-2); // porcion = ‚ÄúHola Mundo‚Äù 
```

Cuando se indica el inicio y el final, se devuelve la parte de la cadena original comprendida  entre la posici√≥n inicial y la inmediatamente anterior a la posici√≥n final (es decir, la  posici√≥n inicio est√° incluida y la posici√≥n final no): 


```JavaScript
var mensaje = ‚ÄúHola Mundo‚Äù; 
var porcion = mensaje.substring(1, 8); // porcion = ‚Äúola Mun‚Äù 
porcion = mensaje.substring(3, 4); // porcion = ‚Äúa‚Äù
```

Si se indica un final m√°s peque√±o que el inicio, JavaScript los considera de forma inversa,  ya que autom√°ticamente asigna el valor m√°s peque√±o al inicio y el m√°s grande al final: 

```JavaScript
var mensaje = ‚ÄúHola Mundo‚Äù; 
var porcion = mensaje.substring(5, 0); // porcion = ‚ÄúHola ‚Äù 
porcion = mensaje.substring(0, 5); // porcion = ‚ÄúHola ‚Äù 
```

- **split(separador)**, convierte una cadena de texto en un array de cadenas de texto. La  funci√≥n parte la cadena de texto determinando sus trozos a partir del  car√°cter separador indicado: 


```JavaScript
var mensaje = ‚ÄúHola Mundo, soy una cadena de texto!‚Äù; 
var palabras = mensaje.split(‚Äù ‚Äú); 
// palabras = [‚ÄúHola‚Äù, ‚ÄúMundo,‚Äù, ‚Äúsoy‚Äù, ‚Äúuna‚Äù, ‚Äúcadena‚Äù, ‚Äúde‚Äù, ‚Äútexto!‚Äù]; 
```

Con esta funci√≥n se pueden extraer f√°cilmente las letras que forman una palabra: 

```JavaScript
var palabra = ‚ÄúHola‚Äù; 
var letras = palabra.split(‚Äú‚Äù); // letras = [‚ÄúH‚Äù, ‚Äúo‚Äù, ‚Äúl‚Äù, ‚Äúa‚Äù]
```


#### Funciones √∫tiles para Arrays 

A continuaci√≥n se muestran algunas de las funciones m√°s √∫tiles para el manejo de arrays: 

- **length**, calcula el n√∫mero de elementos de un array 


```JavaScript
var vocales = [‚Äúa‚Äù, ‚Äúe‚Äù, ‚Äúi‚Äù, ‚Äúo‚Äù, ‚Äúu‚Äù]; 
var numeroVocales = vocales.length; // numeroVocales = 5 
```

- **concat()**, se emplea para concatenar los elementos de varios arrays 


```JavaScript
var array1 = [1, 2, 3]; 
array2 = array1.concat(4, 5, 6); // array2 = [1, 2, 3, 4, 5, 6] 
array3 = array1.concat([4, 5, 6]); // array3 = [1, 2, 3, 4, 5, 6] 
```


- **join(separador)**, es la funci√≥n contraria a split(). Une todos los elementos de un array para  formar una cadena de texto. Para unir los elementos se utiliza el car√°cter separador indicado 

```JavaScript
var array = [‚Äúhola‚Äù, ‚Äúmundo‚Äù]; 
var mensaje = array.join(‚Äú‚Äù); // mensaje = ‚Äúholamundo‚Äù 
mensaje = array.join(‚Äù ‚Äú); // mensaje = ‚Äúhola mundo‚Äù
```


- **pop()**, elimina el √∫ltimo elemento del array y lo devuelve. El array original se modifica y su  longitud disminuye en 1 elemento. 


```JavaScript
var array = [1, 2, 3]; 
var ultimo = array.pop(); 
// ahora array = [1, 2], ultimo = 3 
```

- **push()**, a√±ade un elemento al final del array. El array original se modifica y aumenta su  longitud en 1 elemento. (Tambi√©n es posible a√±adir m√°s de un elemento a la vez) 


```JavaScript
var array = [1, 2, 3]; 
array.push(4); 
// ahora array = [1, 2, 3, 4] 
```


- **shift()**, elimina el primer elemento del array y lo devuelve. El array original se ve  modificado y su longitud disminuida en 1 elemento. 


```JavaScript
var array = [1, 2, 3]; 
var primero = array.shift(); 
// ahora array = [2, 3], primero = 1
```


- **unshift()**, a√±ade un elemento al principio del array. El array original se modifica y aumenta  su longitud en 1 elemento. (Tambi√©n es posible a√±adir m√°s de un elemento a la vez) 


```JavaScript
var array = [1, 2, 3]; 
array.unshift(0); 
// ahora array = [0, 1, 2, 3] 
```


- **reverse()**, modifica un array colocando sus elementos en el orden inverso a su posici√≥n  original: 


```JavaScript
var array = [1, 2, 3]; 
array.reverse(); 
// ahora array = [3, 2, 1]
```


#### Funciones √∫tiles para N√∫meros 

A continuaci√≥n se muestran algunas de las funciones y propiedades m√°s √∫tiles para el  manejo de n√∫meros. 

- **NaN**, (del ingl√©s, ‚ÄúNot a Number‚Äù) JavaScript emplea el valor NaN para indicar un valor  num√©rico no definido (por ejemplo, la divisi√≥n 0/0). 


```JavaScript
var numero1 = 0; 
var numero2 = 0; 
alert(numero1/numero2); // se muestra el valor NaN 
```


- **isNaN()**, permite proteger a la aplicaci√≥n de posibles valores num√©ricos no definidos var numero1 = 0; 

```JavaScript
var numero2 = 0; 

if(isNaN(numero1/numero2)) { 
 alert(‚ÄúLa divisi√≥n no est√° definida para los n√∫meros indicados‚Äù); 
} else { 
 alert(‚ÄúLa divisi√≥n es igual a => ‚Äù + numero1/numero2); 
}
```


- **Infinity**, hace referencia a un valor num√©rico infinito y positivo (tambi√©n existe el valor ‚Äì Infinity para los infinitos negativos) 

```JavaScript
var numero1 = 10; 
var numero2 = 0; 
alert(numero1/numero2); // se muestra el valor Infinity 
```


- **toFixed(digitos)**, devuelve el n√∫mero original con tantos decimales como los indicados por  el par√°metro digitos y realiza los redondeos necesarios. Se trata de una funci√≥n muy √∫til  por ejemplo para mostrar precios. 

```JavaScript
var numero1 = 4564.34567; 
numero1.toFixed(2); // 4564.35 
numero1.toFixed(6); // 4564.345670 
numero1.toFixed(); // 4564
```


#### Sentencia break/continue y otras estructuras de control 

La estructura de control for es muy sencilla de utilizar, pero tiene el inconveniente de que  el n√∫mero de repeticiones que se realizan s√≥lo se pueden controlar mediante las variables  definidas en la zona de actualizaci√≥n del bucle. 

Las sentencias break y continue permiten manipular el comportamiento normal de los  bucles for para detener el bucle o para saltarse algunas repeticiones. Concretamente, la  sentencia break permite terminar de forma abrupta un bucle y la  

sentencia continue permite saltarse algunas repeticiones del bucle. 

El siguiente ejemplo muestra el uso de la sentencia break: 


```JavaScript
var cadena = ‚ÄúEn un lugar de la Mancha de cuyo nombre no quiero acordarme‚Ä¶‚Äù; 
var letras = cadena.split(‚Äú‚Äù); 
var resultado = ‚Äú‚Äù; 

for(i in letras) { 
 if(letras[i] == ‚Äòa‚Äô) { 
 break; 
}  else { 
 resultado += letras[i]; 
 } 
} 

alert(resultado); // muestra ‚ÄúEn un lug‚Äù
```


Si el programa llega a una instrucci√≥n de tipo break;, sale inmediatamente del bucle y  contin√∫a ejecutando el resto de instrucciones que se encuentran fuera del bucle for. En el  ejemplo anterior, se recorren todas las letras de una cadena de texto y cuando se  encuentra con la primera letra ‚Äúa‚Äù, se detiene la ejecuci√≥n del bucle for. 

La utilidad de break es terminar la ejecuci√≥n del bucle cuando una variable toma un  determinado valor o cuando se cumple alguna condici√≥n. 

En ocasiones, lo que se desea es saltarse alguna repetici√≥n del bucle cuando se dan  algunas condiciones. Siguiendo con el ejemplo anterior, ahora se desea que el texto de  salida elimine todas las letras ‚Äúa‚Äù de la cadena de texto original: 


```JavaScript
var cadena = ‚ÄúEn un lugar de la Mancha de cuyo nombre no quiero acordarme‚Ä¶‚Äù; 
var letras = cadena.split(‚Äú‚Äù); 
var resultado = ‚Äú‚Äù; 

for(i in letras) { 
 if(letras[i] == ‚Äòa‚Äô) { 
 continue; 
}  else { 
 resultado += letras[i]; 
 } 
} 

alert(resultado); // muestra ‚ÄúEn un lugr de l Mnch de cuyo nombre no quiero cordrme‚Ä¶‚Äù
```

En este caso, cuando se encuentra una letra ‚Äúa‚Äù no se termina el bucle, sino que no se  ejecutan las instrucciones de esa repetici√≥n y se pasa directamente a la siguiente  repetici√≥n del bucle for. 

La utilidad de continue es que permite utilizar el bucle for para filtrar los resultados en  funci√≥n de algunas condiciones o cuando el valor de alguna variable coincide con un valor  determinado. 



#### Bucles 

Las estructuras de control de flujo que se han visto (if, else, for) y las sentencias que  modifican su comportamiento (break, continue) no son suficientes para realizar algunas  tareas complejas y otro tipo de repeticiones. Por ese motivo, JavaScript proporciona otras  estructuras de control de flujo diferentes y en algunos casos m√°s eficientes. 

#### Estructura While 

La estructura while permite crear bucles que se ejecutan ninguna o m√°s veces,  dependiendo de la condici√≥n indicada. Su definici√≥n formal es: 


```
while(condicion) { 
 ‚Ä¶ 
} 
```

El funcionamiento del bucle while se resume en: ‚Äúmientras se cumpla la condici√≥n  indicada, repite indefinidamente las instrucciones incluidas dentro del bucle‚Äù. 

Si la condici√≥n no se cumple ni siquiera la primera vez, el bucle no se ejecuta. Si la  condici√≥n se cumple, se ejecutan las instrucciones una vez y se vuelve a comprobar la  condici√≥n. Si se sigue cumpliendo la condici√≥n, se vuelve a ejecutar el bucle y as√≠ se  contin√∫a hasta que la condici√≥n no se cumpla. 

Evidentemente, las variables que controlan la condici√≥n deben modificarse dentro del  propio bucle, ya que de otra forma, la condici√≥n se cumplir√≠a siempre y el bucle while se  repetir√≠a indefinidamente.

El siguiente ejemplo utiliza el bucle while para sumar todos los n√∫meros menores o  iguales que otro n√∫mero: 


```JavaScript
var resultado = 0; 
var numero = 100; 
var i = 0; 

while(i <= numero) { 
 resultado += i; 
 i++; 
} 

alert(resultado); 
```

El programa debe sumar todos los n√∫meros menores o igual que otro dado. Por ejemplo si  el n√∫mero es 5, se debe calcular: 1 + 2 + 3 + 4 + 5 = 15 

Este tipo de condiciones ‚Äúsuma n√∫meros mientras sean menores o iguales que otro  n√∫mero dado‚Äù) se resuelven muy f√°cilmente con los bucles tipo while, aunque tambi√©n se  pod√≠an resolver con bucles de tipo for. 

En el ejemplo anterior, mientras se cumpla la condici√≥n, es decir, mientras que la  variable i sea menor o igual que la variable numero, se ejecutan las instrucciones del  bucle. 

Dentro del bucle se suma el valor de la variable i al resultado total (variable resultado) y se  actualiza el valor de la variable i, que es la que controla la condici√≥n del bucle. Si no se  actualiza el valor de la variable i, la ejecuci√≥n del bucle continua infinitamente o hasta que  el navegador permita al usuario detener el script.



#### Estructura Do‚Ä¶while 

El bucle de tipo do‚Ä¶while es muy similar al bucle while, salvo que en este caso siempre se  ejecutan las instrucciones del bucle al menos la primera vez. Su definici√≥n formal es: 

```
do { 
 ‚Ä¶ 
} while(condicion); 
```


De esta forma, como la condici√≥n se comprueba despu√©s de cada repetici√≥n, la primera  vez siempre se ejecutan las instrucciones del bucle. Es importante no olvidar que despu√©s  del while() se debe a√±adir el car√°cter ; (al contrario de lo que sucede con el  bucle while simple). 

Utilizando este bucle se puede calcular f√°cilmente el factorial de un n√∫mero: 


```JavaScript
var resultado = 1; 
var numero = 5; 

do { 
 resultado *= numero; // resultado = resultado * numero 
 numero‚Äì; 
} while(numero > 0); 

alert(resultado);
```


En el c√≥digo anterior, el resultado se multiplica en cada repetici√≥n por el valor de la  variable numero. Adem√°s, en cada repetici√≥n se decrementa el valor de esta  variable numero. La condici√≥n del bucle do‚Ä¶while es que el valor de numero sea mayor  que 0, ya que el factorial de un n√∫mero multiplica todos los n√∫meros menores o iguales  que √©l mismo, pero hasta el n√∫mero 1 (el factorial de 5 por ejemplo es 5 x 4 x 3 x 2 x 1 =  120). 

Como en cada repetici√≥n se decrementa el valor de la variable numero y la condici√≥n es  que numero sea mayor que cero, en la repetici√≥n en la que numero valga 0, la condici√≥n  ya no se cumple y el programa se sale del bucle do‚Ä¶while. 



#### Estructura Switch 

La estructura if‚Ä¶else se puede utilizar para realizar comprobaciones m√∫ltiples y tomar  decisiones complejas. Sin embargo, si todas las condiciones dependen siempre de la  misma variable, el c√≥digo JavaScript resultante es demasiado redundante: 

```
if(numero == 5) { 
 ‚Ä¶ 
}  else if(numero == 8) { 
 ‚Ä¶ 
}  else if(numero == 20) { 
 ‚Ä¶ 
} ‚Ä¶
```


En estos casos, la estructura switch es la m√°s eficiente, ya que est√° especialmente  dise√±ada para manejar de forma sencilla m√∫ltiples condiciones sobre la misma variable. Su  definici√≥n formal puede parecer compleja, aunque su uso es muy sencillo: 

```
switch(variable) { 
 case valor_1: 
    ‚Ä¶ 
    break; 

 case valor_2: 
    ‚Ä¶ 
    break; 
 ‚Ä¶ 
 case valor_n: 
    ‚Ä¶ 
    break; 

 default: 
   ‚Ä¶ 
   break; 
}
```
El anterior ejemplo realizado con if‚Ä¶else se puede rehacer mediante switch: switch(numero) { 


```
 case 5: 
   ‚Ä¶ 
   break; 
 case 8: 
   ‚Ä¶ 
   break; 
 case 20: 
   ‚Ä¶ 
   break; 
 default: 
   ‚Ä¶ 
   break; 
}
```

La estructura switch se define mediante la palabra reservada switch seguida, entre  par√©ntesis, del nombre de la variable que se va a utilizar en las comparaciones. Como es  habitual, las instrucciones que forman parte del switch se encierran entre las llaves { y }. 

Dentro del switch se definen todas las comparaciones que se quieren realizar sobre el  valor de la variable. Cada comparaci√≥n se indica mediante la palabra  reservada case seguida del valor con el que se realiza la comparaci√≥n. Si el valor de la  variable utilizada por switch coincide con el valor indicado por case, se ejecutan las  instrucciones definidas dentro de ese case. 

Normalmente, despu√©s de las instrucciones de cada case se incluye la  sentencia break para terminar la ejecuci√≥n del switch, aunque no es obligatorio. Las  comparaciones se realizan por orden, desde el primer case hasta el √∫ltimo, por lo que es  muy importante el orden en el que se definen los case. 

¬øQu√© sucede si ning√∫n valor de la variable del switch coincide con los valores definidos en  los case? En este caso, se utiliza el valor default para indicar las instrucciones que se  ejecutan en el caso en el que ning√∫n case se cumpla para la variable indicada. 

Aunque default es opcional, las estructuras switch suelen incluirlo para definir al menos  un valor por defecto para alguna variable o para mostrar alg√∫n mensaje por pantalla.

---
---

## :star: Variables


### ¬øQu√© son las variables?

¬°Hola! Seguimos profundizando en los aspectos m√°s importantes de JavaScript; en este sentido vamos a destacar la definici√≥n y uso de las variables. En programaci√≥n, las variables son contenedores que nos permiten almacenar valores num√©ricos, cadenas de caracteres o estructuras de datos como listas, arreglos de valores u objetos. Por el momento, vamos a estudiar las variables que almacenan valores simples como n√∫meros o cadenas de caracteres. La principal propiedad de las variables, como su nombre lo indica, es almacenar valores que pueden cambiar a lo largo de la ejecuci√≥n del programa; es por esta raz√≥n que reciben el nombre de variables. 

Estos valores almacenados se pueden utilizar o acceder en cualquier momento de la ejecuci√≥n de nuestro programa. As√≠ como en √°lgebra utilizamos variables para trabajar con ecuaciones y f√≥rmulas complejas, en programaci√≥n trabajamos con variables para poder ejecutar los pasos que componen los algoritmos de la aplicaci√≥n que estamos codificando.

Ya que vimos algunas propiedades de las variables, pasemos a aprender c√≥mo utilizarlas en JavaScript.

Para declarar una variable es necesario tener presente la siguiente estructura:

```JavaScript
var x = 5;
```


### Estructura b√°sica para la declaraci√≥n de variables

A continuaci√≥n se describen los componentes de la estructura b√°sica para la declaraci√≥n de variables en JavaScript:

var es la palabra reservada que le indica a JavaScript que estamos declarando una variable.

```x``` es el nombre que le asignamos a la variable.

```= ```es el operador de asignaci√≥n que le indica a JavaScript qu√© valor asignar.

```5``` corresponde al valor inicial que vamos a almacenar en la variable.


### Buenas pr√°cticas

Los nombres de las variables son muy flexibles aunque te recomendamos estas buenas pr√°cticas para nombrar tus variables:

- Los nombres deben expresar el contenido de la variable, as√≠ hacemos nuestro c√≥digo m√°s entendible a otros programadores; por ejemplo, si en la variable almacenamos la edad de un estudiante entonces la variable puede llamarse: edad, edadEstudiante o edadAlumno.

- El nombre de las variables puede contener los caracteres, underscore (``` _ ```), o signo de d√≥lar ( ```$``` ) al inicio, en medio o al final del nombre.

- El nombre de las variables debe iniciar con una letra ASCII sea may√∫scula o min√∫scula, tambi√©n puede empezar con un gui√≥n bajo (```_```) o un signo de d√≥lar (```$```).

- Para separar las palabras que componen el nombre de la variable, JavaScript utiliza la convenci√≥n camelCase, la cual indica que las variables empiezan en min√∫scula y cuando cambias de palabra inicias el primer car√°cter con letra may√∫scula. 

Por ejemplo: 

para nombrar la variable color del carro puedes utilizar los siguientes nombres: colorCarro o colorDelCarro.


- No debes usar palabras reservadas de JavaScript para nombrar variables.


- El nombre de las variables no debe empezar con n√∫meros.

- El nombre de las variables no puede contener caracteres especiales como: &, ~, %, #.

- Las variables en JavaScript nunca pueden iniciar con n√∫meros, pero s√≠ pueden contener n√∫meros en la mitad o al final del nombre.


A continuaci√≥n tienes unos ejemplos de nombres de variables v√°lidos en JavaScript:

Ejemplo

```JavaScript
var pizza2go = "pizza";
var aprendo_JAVASCRIPT = true;
var $_$ = "moneda";
var _saludo = "Hola";
var nombreVariable = "camel case";
```


Aqu√≠ puedes ver algunos ejemplos de nombres inv√°lidos para las variables:

Ejemplo

```
>var function = true;
>var total% = 125;
>var class = "variables";
>var 2nombre = "clase de variables";
```
Las variables son sensibles a may√∫sculas de manera que miVar, MiVar, mivar son variables completamente diferentes. Es una buena pr√°ctica de programaci√≥n, evitar nombres similares entre las variables, o nombres que no nos den una referencia clara de cu√°l puede ser su contenido, por ejemplo:

```var x = true;```

Despu√©s de declarar una variable, es posible hacer referencia a √©sta (utilizar u obtener el valor de la variable) por su nombre en cualquier parte de nuestro programa, teniendo en cuenta el scope o √°mbito de las variables que estudiaremos m√°s adelante. As√≠ como tambi√©n podemos hacer diferentes operaciones con las mismas.

C√≥digo

```
>var valor1 = 5;
>var valor2 = 7;
>valor1 + valor2;
```
Resultado: 12

En el ejemplo anterior se declararon dos variables (valor1) y (valor2) que luego son utilizadas en una suma; al sumar las dos variables, el resultado es 12.

Tambi√©n es posible hacer uso de variables cuando estamos declarando otras variables:

```var suma = valor1 + 95;```

Despu√©s de declarar variables ( var ) podemos re-asignar nuevos valores o datos para que sean almacenados en dichas variables:

C√≥digo
```
>var nombre = "carlos";
>nombre = "pedro";
>nombre;```

Resultado

pedro

En JavaScript, otra manera de declarar variables se puede lograr usando los comandos let y const, palabras reservadas para el lenguaje, definidas en el est√°ndar ECMAScript 6. Con el comando let declaramos variables limitando su uso a un bloque de c√≥digo determinado, mientras que con el comando const definimos constantes o variables que tendr√°n un valor que no podr√° modificarse posteriormente.


---
---

## :star: Funciones de Java Script


#### Funciones 

Las funciones son uno de los bloques de construcci√≥n fundamentales en JavaScript. Una  funci√≥n en JavaScript es similar a un procedimiento ‚Äî un conjunto de instrucciones que  realiza una tarea o calcula un valor, pero para que un procedimiento califique como  funci√≥n, debe tomar alguna entrada y devolver una salida donde hay alguna relaci√≥n obvia  entre la entrada y la salida. Para usar una funci√≥n, debes definirla en alg√∫n lugar del  √°mbito desde el que deseas llamarla. 

Programar, usando un s√≠mil, podemos verlo como realizar un viaje por carretera. Cuando  realizamos un viaje, aparte de la necesidad de definir el objetivo y estudiar la ruta del viaje  (estructura del programa) podemos decir que: ‚ÄúEn general, pero sobre todo para viajes  complicados, conviene dividir el problema en subapartados‚Äù. 

El concepto de funci√≥n aplicado a la programaci√≥n JavaScript es muy similar al aplicable a  distintas facetas de la vida: un escritor divide su curso en cap√≠tulos y ap√©ndices. Un  profesor divide el contenido de la asignatura en temas. Un ingeniero divide el proyecto en  partes como Memoria, Anejos, Pliego de Condiciones, Presupuesto y Planos. En una  f√°brica, organizan el trabajo dividiendo las √°reas funcionales en recepci√≥n de materias  primas, √°rea de pre-proceso, √°rea de proceso, √°rea de post-proceso y √°rea de carga y  despacho de producto terminado. 

De cara a la programaci√≥n JavaScript, usaremos la divisi√≥n del c√≥digo en funciones por ser  una estrategia efectiva para resolver problemas complejos. Cada funci√≥n ser√° llamada  para realizar su cometido en un orden establecido. 

Adem√°s una funci√≥n se puede llamar tantas veces como se desee, lo cual evita tener que  repetir c√≥digo y por otro lado permite que cuando haya que realizar una correcci√≥n  √∫nicamente tengamos que hacerla en la funci√≥n concreta que se ve afectada. 

Las funciones pueden recibir informaci√≥n para realizar su cometido, por ejemplo function  suma (a, b) recibe dos elementos de informaci√≥n: a y b, o no recibirla por realizar un  proceso que no necesita recibir informaci√≥n, por ejemplo function dibujarCirculo(). 

#### Otra caracter√≠stica interesante de las funciones es que permite abstraer los problemas.  

Supongamos que necesitamos una funci√≥n que devuelva para un importe de una compra  sin impuestos el importe con impuestos, y que a su vez el porcentaje de impuestos a  aplicar depende del tipo de producto. Si un compa√±ero nos facilita la funci√≥n function  obtenerImporteConImpuestos (importeSinImpuestos) no tenemos que preocuparnos del  c√≥digo de la funci√≥n. Unicamente sabemos que invocando a la funci√≥n obtendremos el  importe con impuestos. De esta forma, podemos utilizar funciones que han creado otros  programadores o funciones disponibles en librer√≠as sin necesidad de conocer el c√≥digo de  las mismas. Decimos que las funciones son ‚Äúcajas negras‚Äù que facilitan la abstracci√≥n  porque no necesitamos ver en su interior, s√≥lo nos interesan sus resultados.

De hecho, es posible que un programador use un c√≥digo para una funci√≥n function  obtenerImporteConImpuestos (importeSinImpuestos) y otro programador use otro c√≥digo  para esa misma funci√≥n sin que esto suponga ning√∫n problema. Lo importante es que la  funci√≥n realice su cometido, no c√≥mo lo realice ya que es frecuente que haya distintas  maneras de hacer algo (aunque ciertamente hacer las cosas de diferente manera no debe  significar que unas veces se hagan bien y otras mal: siempre deber√≠an hacerse las cosas  bien). 

Una funci√≥n en general debe tener un nombre descriptivo de cu√°l es su cometido y tener  un cometido claro y √∫nico. No deben mezclarse tareas que no tengan relaci√≥n entre s√≠  dentro de una funci√≥n. 


#### Funciones con Par√°metros y sin Par√°metros 

Una funci√≥n JavaScript puede requerir ser llamada pas√°ndole cierta informaci√≥n o no  requerir informaci√≥n. 

Definici√≥n de una funci√≥n sin par√°metros (no requiere informaci√≥n): 

```
// Comentario descriptivo de qu√© hace la funci√≥n 

function nombreDeLaFunci√≥n () {  
 // C√≥digo de la funci√≥n 
} 
```

Definici√≥n de una funci√≥n con par√°metros (requiere informaci√≥n): 

```
// Comentario descriptivo de qu√© hace la funci√≥n 

function nombreDeLaFunci√≥n (param1, param2, ‚Ä¶, paramN) {  
 // C√≥digo de la funci√≥n 
} 
```


Una funci√≥n puede recibir tantos par√°metros como se deseen, aunque no ser√≠a demasiado  razonable que una funci√≥n reciba m√°s de cuatro o cinco par√°metros. Los par√°metros que se le pasan a la funci√≥n pueden ser: 

- a) Valores simples a los que se denomina literales: por ejemplo 554, true √≥ ‚Äòaldea‚Äô. 

- b) Variables que contienen un n√∫mero, un texto o un valor booleano. 

- c) Objetos de naturaleza compleja, como arrays y otros tipos de objetos que veremos m√°s
Cuando una funci√≥n recibe un par√°metro dicho par√°metro funciona como si se tratara de  una variable disponible para la funci√≥n inicializada con el valor que se le pasa a la funci√≥n. 

Veamos un ejemplo: 

```JavaScript
function mostrarImporteConImpuestos(importeSinImpuestos) { 
   var importeConImpuestos; 
   importeConImpuestos = importeSinImpuestos * 1.21;  
   msg = ‚ÄòImporte antes de impuestos: ‚Äò+ importeSinImpuestos + ‚Äò\n\n‚Äô; 
   alert(msg + ‚ÄòImporte con impuestos: ‚Äò+ importeConImpuestos + ‚Äò\n\n‚Äô); 
}
``` 

Aqu√≠ vemos dos cosas de inter√©s: 

el par√°metro que recibe la funci√≥n no tiene un tipo de  datos expl√≠cito. El tipo de datos es ‚Äúinferido‚Äù por el int√©rprete JavaScript. Por otro lado, el par√°metro est√° disponible dentro de la funci√≥n con el valor con el que  haya sido invocado. Por ejemplo onclick=‚ÄùmostrarImporteConImpuestos(100)‚Äù har√° que  importeSinImpuestos valga 100 porque ese es el valor con el que se invoca. Cuando una funci√≥n tiene varios par√°metros, se debe invocar escribiendo su nombre  seguido de los par√°metros en el orden adecuado. 



#### Funciones que devuelven un resultado (return) 

Una funci√≥n JavaScript puede devolver un resultado si se introduce la sentencia return  resultado; donde resultado es aquello que queremos devolver (normalmente una variable  que contiene un valor num√©rico, de texto o booleano, pero tambi√©n podr√≠an ser objetos  con mayor complejidad como un array). 

Una vez se llega a la sentencia return se produce la devoluci√≥n del resultado y se  interrumpe la ejecuci√≥n de la funci√≥n. Por ello la sentencia return ser√° normalmente la  √∫ltima instrucci√≥n dentro de una funci√≥n. 

Definici√≥n de una funci√≥n sin par√°metros que devuelve un resultado: // Comentario descriptivo de qu√© hace la funci√≥n 

```
function nombreDeLaFunci√≥n () {  
  // C√≥digo de la funci√≥n 
  return resultado; 
}
```

Definici√≥n de una funci√≥n con par√°metros que devuelve un resultado: // Comentario descriptivo de qu√© hace la funci√≥n 

```
function nombreDeLaFunci√≥n (param1, param2, ‚Ä¶, paramN) {  
 // C√≥digo de la funci√≥n 
 return resultado; 
} 
```

Una funci√≥n s√≥lo devolver√° un resultado y normalmente s√≥lo tendr√° una sentencia return,  aunque si hay sentencias condicionales como if, puede haber varias sentencias return: una  sentencia return para cada sentencia condicional. 

Si adem√°s del resultado la funci√≥n incluye c√≥digo que implique acciones como mostrar un  mensaje por pantalla, se ejecutar√° el c√≥digo a la vez que se devuelve el resultado. 

Veamos un ejemplo: 

```JavaScript
function obtenerImporteConImpuestos(importeSinImpuestos) { 
    var importeConImpuestos; 
    importeConImpuestos = importeSinImpuestos * 1.21; 
    return importeConImpuestos; 
} 
```

Un ejemplo de uso de esta funci√≥n ser√≠a: 

```onclick=‚Äùalert(‚ÄòCalculado para producto de precio 100: importe con impuestos vale ‚Äò +  obtenerImporteConImpuestos(100));‚Äù```


### Llamadas a Funciones desde otras funciones 

Una funci√≥n puede llamar a otra funci√≥n simplemente escribiendo su nombre y los  par√°metros que sean necesarios. Ejemplo: 


```
function mostrarImporteConImpuestos2(importeSinImpuestos) { 

    var msg; msg = ‚ÄòEjemplo. Importe antes de impuestos: ‚Äò+ importeSinImpuestos + ‚Äò\n\n‚Äô;  
    alert(msg + ‚ÄòImporte con impuestos: ‚Äò+  obtenerImporteConImpuestos(importeSinImpuestos) + ‚Äò\n\n‚Äô); 
} 
```
En esta funci√≥n en vez de realizarse el c√°lculo del importe con impuestos, se invoca otra  funci√≥n que es la que se encarga de realizar el c√°lculo y devolver el valor correspondiente. 


###5 Par√°metros 

Los par√°metros son variables locales a los que se les asigna un valor antes de comenzar la  ejecuci√≥n del cuerpo de una funci√≥n. Su √°mbito de validez, por tanto, es el propio cuerpo  de la funci√≥n. El mecanismo de paso de par√°metros a las funciones es fundamental para  comprender el comportamiento de los programas 

#### Paso de par√°metros a Funciones 

Hay dos formas comunes de pasar par√°metros a funciones en programaci√≥n: por valor,  que implica que si se pasa una variable sus cambios s√≥lo son conocidos dentro de la  funci√≥n, o por variable, que implica que si se pasa una variable √©sta puede ser modificada  por la funci√≥n y sus cambios ser conocidos fuera de la funci√≥n. JavaScript trabaja con paso  de par√°metros por valor, lo que implica que la variable pasada como par√°metro funciona  como una variable local a la funci√≥n: si el par√°metro sufre cambios, estos cambios s√≥lo  son conocidos dentro de la funci√≥n. La variable ‚Äúverdadera‚Äù no puede ser modificada. 


- Paso de un n√∫mero de par√°metros incorrectos 

Si se pasan m√°s par√°metros de los necesarios, JavaScript ignorar√° los par√°metros  sobrantes. Si se pasan menos par√°metros de los necesarios, JavaScript asignar√° valor  undefined a los par√°metros de los que no se recibe informaci√≥n y se ejecutar√° sin que  surja ning√∫n mensaje de error (aparte de los posibles resultados extra√±os que esto  pudiera ocasionar).


### Variables globales y locales 

El √°mbito de una variable (llamado ‚Äúscope‚Äù en ingl√©s) es la zona del programa en la que se  define la variable. JavaScript define dos √°mbitos para las variables: global y local. El siguiente ejemplo ilustra el comportamiento de los √°mbitos: 


```JavaScript
function creaMensaje() { 
 var mensaje = ‚ÄúMensaje de prueba‚Äù; 
} 

creaMensaje(); 

alert(mensaje); 
```


El ejemplo anterior define en primer lugar una funci√≥n llamada creaMensaje que crea una  variable llamada mensaje. A continuaci√≥n, se ejecuta la funci√≥n mediante la llamada  creaMensaje(); y seguidamente, se muestra mediante la funci√≥n alert() el valor de una  variable llamada mensaje. 

Sin embargo, al ejecutar el c√≥digo anterior no se muestra ning√∫n mensaje por pantalla. La  raz√≥n es que la variable mensaje se ha definido dentro de la funci√≥n creaMensaje() y por  tanto, es una variable local que solamente est√° definida dentro de la funci√≥n. 

Cualquier instrucci√≥n que se encuentre dentro de la funci√≥n puede hacer uso de esa  variable, pero todas las instrucciones que se encuentren en otras funciones o fuera de  cualquier funci√≥n no tendr√°n definida la variable mensaje.  

De esta forma, para mostrar el mensaje en el c√≥digo anterior, la funci√≥n alert() debe  llamarse desde dentro de la funci√≥n creaMensaje(): 


```JavaScript
function creaMensaje() { 
 var mensaje = ‚ÄúMensaje de prueba‚Äù; 
 alert(mensaje); 
} 

creaMensaje();
```


Adem√°s de variables locales, tambi√©n existe el concepto de variable global, que est√°  definida en cualquier punto del programa (incluso dentro de cualquier funci√≥n). 

```
var mensaje = ‚ÄúMensaje de prueba‚Äù; 


function muestraMensaje() { 
 alert(mensaje); 
} 
```


El c√≥digo anterior es el ejemplo inverso al mostrado anteriormente. Dentro de la funci√≥n  muestraMensaje() se quiere hacer uso de una variable llamada mensaje y que no ha sido  definida dentro de la propia funci√≥n.  

Sin embargo, si se ejecuta el c√≥digo anterior, s√≠ que se muestra el mensaje definido por la  variable mensaje. 

El motivo es que en el c√≥digo JavaScript anterior, la variable mensaje se ha definido fuera  de cualquier funci√≥n. Este tipo de variables autom√°ticamente se transforman en variables  globales y est√°n disponibles en cualquier punto del programa (incluso dentro de cualquier  funci√≥n). 

De esta forma, aunque en el interior de la funci√≥n no se ha definido ninguna variable  llamada mensaje, la variable global creada anteriormente permite que la instrucci√≥n  alert() dentro de la funci√≥n muestre el mensaje correctamente. 

Si una variable se declara fuera de cualquier funci√≥n, autom√°ticamente se transforma en  variable global independientemente de si se define utilizando la palabra reservada var o  no. Sin embargo, las variables definidas dentro de una funci√≥n pueden ser globales o  locales. 

Si en el interior de una funci√≥n, las variables se declaran mediante var se consideran  locales y las variables que no se han declarado mediante var, se transforman  autom√°ticamente en variables globales. 

Por lo tanto, se puede rehacer el c√≥digo del primer ejemplo para que muestre el mensaje  correctamente. Para ello, simplemente se debe definir la variable dentro de la funci√≥n sin  la palabra reservada var, para que se transforme en una variable global: 


```JavaScript
function creaMensaje() { 
 mensaje = ‚ÄúMensaje de prueba‚Äù; 
} 

creaMensaje(); 

alert(mensaje);
```


### ¬øQu√© sucede si una funci√≥n define una variable local con el mismo nombre que una  variable global que ya existe? 

En este caso, las variables locales prevalecen sobre las  globales, pero s√≥lo dentro de la funci√≥n: 


```JavaScript
var mensaje = ‚Äúgana la de fuera‚Äù; 

function muestraMensaje() { 

 var mensaje = ‚Äúgana la de dentro‚Äù; 

 alert(mensaje); 

} 

alert(mensaje); 

muestraMensaje(); 

alert(mensaje); 

```

El c√≥digo anterior muestra por pantalla los siguientes mensajes: 

```
gana la de fuera 

gana la de dentro 

gana la de fuera 
```


Dentro de la funci√≥n, la variable local llamada mensaje tiene m√°s prioridad que la variable  global del mismo nombre, pero solamente dentro de la funci√≥n. 


### ¬øQu√© sucede si dentro de una funci√≥n se define una variable global con el mismo nombre  que otra variable global que ya existe? 

En este otro caso, la variable global definida dentro  de la funci√≥n simplemente modifica el valor de la variable global definida anteriormente: 


```JavaScript
var mensaje = ‚Äúgana la de fuera‚Äù; 

function muestraMensaje() { 

 mensaje = ‚Äúgana la de dentro‚Äù; 

 alert(mensaje); 

} 

alert(mensaje); 

muestraMensaje(); 

alert(mensaje); 
```



En este caso, los mensajes mostrados son: 
```
gana la de fuera 

gana la de dentro 

gana la de dentro
```


### Objetos 

Un objeto es una colecci√≥n de datos relacionados y/o funcionalidad (que generalmente  consta de algunas variables y funciones, que se denominan propiedades y m√©todos  cuando est√°n dentro de objetos). Vamos a trabajar a trav√©s de un ejemplo para mostrarte  c√≥mo son. 

Al igual que con muchas cosas en JavaScript, la creaci√≥n de un objeto a menudo comienza  con la definici√≥n e iniciaci√≥n de una variable. 

```
var persona = {}; 
```

Si ingresas persona en tu entrada de texto y presionas el bot√≥n, debes obtener el  siguiente resultado: 

```[objeto Objeto] ```

¬°Felicidades!, acabas de crear tu primer objeto. ¬°Trabajo realizado! Pero este es un objeto  vac√≠o, por lo que realmente no podemos hacer mucho con √©l. Actualicemos nuestro  objeto para que se vea as√≠: 

```JavaScript
var persona = { 
 nombre: [‚ÄòBob‚Äô, ‚ÄòSmith‚Äô], 
 edad: 32, 
 genero: ‚Äòmasculino‚Äô, 
 intereses: [‚Äòm√∫sica‚Äô, ‚Äòesqu√≠‚Äô], 

 bio: function () { 
     alert(this.nombre[0] + ‚Äù + this.nombre[1] + ‚Äò tiene ‚Äò + this.edad + ‚Äò a√±os. Le gusta ‚Äò +  this.intereses[0] + ‚Äò y ‚Äò + this.intereses[1] + ‚Äò.‚Äô); 
 }, 

 saludo: function() { 
    alert(‚ÄòHola, Soy ‚Äò+ this.nombre[0] + ‚Äò. ‚Äò); 
 } 

}; 
```
Despu√©s de guardar y actualizar, intenta ingresar algunos de los siguientes en tu entrada  de texto: 


```JavaScript
persona.nombre 
persona.nombre[0] 
persona.edad 
persona.intereses[1] 
persona.bio() 
persona.saludo()
```


¬°Ahora tienes algunos datos y funcionalidades dentro de tu objeto, y ahora puedes  acceder a ellos con una sintaxis simple y agradable! 

Un objeto se compone de varios miembros, cada uno de los cuales tiene un nombre (por  ejemplo, nombre y edad) y un valor (por ejemplo, [‚ÄòBob‚Äô, ‚ÄòSmith‚Äô] y 32). Cada par  nombre/valor debe estar separado por una coma, y el nombre y el valor en cada caso  est√°n separados por dos puntos. La sintaxis siempre sigue este patr√≥n: 


```JavaScript
var nombreObjeto = { 
 miembro1Nombre: miembro1Valor, 
 miembro2Nombre: miembro2Valor, 
 miembro3Nombre: miembro3Valor 
} 
```

El valor de un miembro de un objeto puede ser pr√°cticamente cualquier cosa: en nuestro  objeto persona tenemos una cadena de texto, un n√∫mero, dos arreglos y dos funciones.  Los primeros cuatro elementos son elementos de datos y se denominan propiedades del  objeto. Los dos √∫ltimos elementos son funciones que le permiten al objeto hacer algo con  esos datos, y se les denomina m√©todos del objeto. 

Un objeto como este se conoce como un objeto literal ‚Äî literalmente hemos escrito el  contenido del objeto tal como lo fuimos creando. Esto est√° en contraste con los objetos  instanciados de las clases, que veremos m√°s adelante. 

Es muy com√∫n crear un objeto utilizando un objeto literal cuando deseas transferir una  serie de elementos de datos relacionados y estructurados de alguna manera, por ejemplo,  enviando una solicitud al servidor para ponerla en una base de datos. Enviar un solo  objeto es mucho m√°s eficiente que enviar varios elementos individualmente, y es m√°s  f√°cil de procesar que con un arreglo, cuando deseas identificar elementos individuales por  nombre.


### Notaci√≥n de punto 

Arriba, accediste a las propiedades y m√©todos del objeto usando notaci√≥n de punto (dot  notation). El nombre del objeto (persona) act√∫a como el espacio de nombre (namespace);  al cual se debe ingresar primero para acceder a cualquier elemento encapsulado dentro  del objeto. A continuaci√≥n, escribe un punto y luego el elemento al que deseas acceder:  puede ser el nombre de una simple propiedad, un elemento de una propiedad de arreglo  o una llamada a uno de los m√©todos del objeto, por ejemplo: 


```
persona.edad 
persona.intereses[1] 
persona.bio() 
```


### Espacios de nombres secundarios 

Incluso es posible hacer que el valor de un miembro del objeto sea otro objeto. Por  ejemplo, intenta cambiar el miembro nombre de 

```nombre: [‚ÄòBob‚Äô, ‚ÄòSmith‚Äô],``` 

a 
```
nombre : { 

 pila: ‚ÄòBob‚Äô, 

 apellido: ‚ÄòSmith‚Äô 

}, 
```

Aqu√≠ estamos creando efectivamente un espacio de nombre secundario (sub-namespace).  Esto suena complejo, pero en realidad no es as√≠: para acceder a estos elementos solo  necesitas un paso adicional que es encadenar con otro punto al final. Prueba estos: 
```
persona.nombre.pila 

persona.nombre.apellido 
```

Importante: en este punto, tambi√©n deber√°s revisar tu c√≥digo y cambiar cualquier  instancia de 
```
nombre[0] 

nombre[1] 
```
a 
```
nombre.pila 

nombre.apellido 
```

De lo contrario, sus m√©todos ya no funcionar√°n.


### Notaci√≥n de corchetes 

Hay otra manera de acceder a las propiedades del objeto, usando la notaci√≥n de  corchetes. En lugar de usar estos: 
```
persona.edad 

persona.nombre.pila 

Puedes usar 

persona[‚Äòedad‚Äô] 

persona[‚Äònombre‚Äô][‚Äòpila‚Äô] 
```

Esto se ve muy similar a c√≥mo se accede a los elementos en un arreglo, y b√°sicamente es  lo mismo: en lugar de usar un n√∫mero de √≠ndice para seleccionar un elemento, se esta  utilizando el nombre asociado con el valor de cada miembro. No es de extra√±ar que los  objetos a veces se denominen arreglos asociativos: asocian cadenas de texto a valores de  la misma manera que las arreglos asocian n√∫meros a valores. 

Establecer miembros de objetos 

Hasta ahora solo hemos buscado recuperar (u obtener) miembros del objeto: tambi√©n  puede establecer (actualizar) el valor de los miembros del objeto simplemente declarando  el miembro que deseas establecer (usando la notaci√≥n de puntos o corchetes), de esta  manera: 
```
persona.edad = 45; 

persona[‚Äònombre‚Äô][‚Äòapellido‚Äô] = ‚ÄòCratchit‚Äô; 

Intenta ingresar estas l√≠neas y luego vuelve a ver a los miembros para ver c√≥mo han  cambiado: 

persona.edad 

persona[‚Äònombre‚Äô][‚Äòapellido‚Äô] 
```

Establecer miembros no solo es actualizar los valores de las propiedades y m√©todos  existentes; tambi√©n puedes crear miembros completamente nuevos. Prueba estos: 
```
persona[‚Äòojos‚Äô] = ‚Äòavellana‚Äô; 

persona.despedida = function() { alert(‚Äú¬°Adi√≥s a todos!‚Äù); } 

Ahora puedes probar a los nuevos miembros: 

persona[‚Äòojos‚Äô] 

person.despedida()
```
Un aspecto √∫til de la notaci√≥n de corchetes es que se puede usar para establecer  din√°micamente no solo los valores de los miembros, sino tambi√©n los nombres de los  miembros. Digamos que queremos que los usuarios puedan almacenar tipos de valores  personalizados en sus datos personales, escribiendo el nombre y el valor del miembro en  dos entradas de texto. Podr√≠amos obtener esos valores de esta manera: 

```
var nombrePerzonalizado = entradaNombre.value; 
var valorPerzonalizado = entradaValor.value; 
```

entonces podr√≠amos agregar este nuevo miembro nombre y valor al objeto persona de  esta manera: 
```
persona[nombrePerzonalizado] = valorPerzonalizado; 
```

Para probar esto, intenta agregar las siguientes l√≠neas en tu c√≥digo, justo debajo de la llave  de cierre del objeto persona: 
```
var nombrePerzonalizado = ‚Äòaltura‚Äô; 
var valorPerzonalizado = ‚Äò1.75m‚Äô; 
persona[nombrePerzonalizado] = valorPerzonalizado; 
```

Ahora intenta guardar y actualizar, e ingresa lo siguiente en tu entrada de texto: persona.altura 

Agregar una propiedad a un objeto no es posible con la notaci√≥n de puntos, que solo  puede aceptar un nombre de miembro literal, no un valor variable que apunte a un  nombre. 

Has estado usando objetos todo el tiempo 

A medida que has estado repasando estos ejemplos, probablemente hayas pensando que  la notaci√≥n de puntos que has usando es muy familiar. ¬°Eso es porque la has estado  usando a lo largo del curso! Cada vez que hemos estado trabajando en un ejemplo que  utiliza una API de navegador incorporada o un objeto JavaScript, hemos estado usando objetos, porque tales caracter√≠sticas se crean usando exactamente el mismo tipo de  estructuras de objetos que hemos estado viendo aqu√≠, aunque m√°s complejos que  nuestros propios ejemplos personalizados.

Entonces cuando usaste m√©todos de cadenas de texto como: 

```myCadena.split(‚Äò,‚Äô); ```

Estabas usando un m√©todo disponible en una instancia de la clase String. Cada vez que  creas una cadena en tu c√≥digo, esa cadena se crea autom√°ticamente como una instancia  de String, y por lo tanto tiene varios m√©todos/propiedades comunes disponibles en ella. 

Cuando accediste al modelo de objetos del documento (document object model) usando  l√≠neas como esta: 
```
var miDiv = document.createElement(‚Äòdiv‚Äô); 
var miVideo = document.querySelector(‚Äòvideo‚Äô); 
```

Estaba usando m√©todos disponibles en una instancia de la clase Document. Para cada  p√°gina web cargada, se crea una instancia de Document, llamada document, que  representa la estructura, el contenido y otras caracter√≠sticas de la p√°gina entera, como su  URL. De nuevo, esto significa que tiene varios m√©todos/propiedades comunes disponibles  en √©l. 

Lo mismo puede decirse de pr√°cticamente cualquier otro Objeto/API incorporado que  hayad estado utilizando: Array, Math, etc. 

Ten en cuenta que los Objetos/API incorporados no siempre crean instancias de objetos  autom√°ticamente. Como ejemplo, la API de Notificaciones, que permite que los  navegadores modernos activen las notificaciones del sistema, requiere que crees una  instancia de un nuevo objeto para cada notificaci√≥n que desees disparar. Intenta ingresar  lo siguiente en tu consola de JavaScript: 
```
var miNotificacion = new Notification(‚Äò¬°Hola!‚Äô); 
```

Nota: Es √∫til pensar en la forma en que los objetos se comunican como paso de mensajes  ‚Äî cuando un objeto necesita otro objeto para realizar alg√∫n tipo de acci√≥n a menudo  enviar√° un mensaje a otro objeto a trav√©s de uno de sus m√©todos, y esperar√° una  respuesta, que conocemos como un valor de retorno.

### Funci√≥n constructura y new 

JavaScript no tiene una notaci√≥n formal de clase y recurre a las funciones constructoras  para este fin. Mencionar tambi√©n que JavaScript utiliza los prototipos de los objetos para  propagar la herencia, algo que sin duda cuesta entender al principio y al que dedicaremos  un art√≠culo independiente m√°s adelante. 

### Funci√≥n constructora 

Una funci√≥n constructora es una funci√≥n normal y corriente de JavaScript que se utiliza  para definir una especie de plantilla para nuestros objetos personalizados. Veamos un  ejemplo: 

```
function Cliente(nombre, fecha, direccion) { 
 this._nombre = nombre; 
 this._fechaNacimiento = fecha; 
 this._direccion = direccion; 
} 
```

Como podemos observar, se trata de una t√≠pica funci√≥n de JavaScript que admite una  serie de par√°metros de entrada aunque estos no son obligatorios en absoluto. La √∫nica  particularidad de esta funci√≥n es que se utiliza la palabra reservada this de JavaScript para  definir una serie de propiedades (tambi√©n podr√°n ser m√©todos) que formar√°n parte de  nuestros objetos personalizados. 

En la ilustraci√≥n lateral vemos c√≥mo podemos utilizar esta funci√≥n constructora para crear  instancias de nuestros objetos personalizados.

El operador new utilizado junto a una funci√≥n de JavaScript es lo que nos permite obtener  un objeto constructor o funci√≥n constructora. Lo que sucede por debajo es que new  primeramente crea un objeto sin propiedades y posteriormente llama a la funci√≥n  pas√°ndole el nuevo objeto como valor de la palabra reservada this. Finalmente, la funci√≥n  nos devuelve un nuevo objeto con las propiedades y m√©todos definidos dentro de la  constructora. 

Como se aprecia en el intellisense de la imagen observamos que el nuevo objeto miCliente  tiene todas las propiedades definidas anteriormente dentro del constructor. 

Como hemos comentado, no es necesario que el constructor tome par√°metros, podemos  crear una plantilla en blanco e ir rellenando los objetos con datos cuando lo necesitemos: 

```
// Constructor vac√≠o 
function Cliente() { 
 this._nombre; 
 this._fechaNacimiento; 
 this._direccion; 
} 
```


```

// Creamos el objeto y le asignamos valores 
var cliente = new Cliente(); 
cliente._nombre = ‚ÄúCristina Rodriguez‚Äù; 
cliente._fechaNacimiento = new Date(1987, 3, 25); 
cliente._direccion = ‚ÄúPlaza Bilbao 25‚Äù;
```


Comprobar la funci√≥n constructora de un objeto 

Todos los objetos de JavaScript, ya sean nativos o de usuario, tienen una propiedad  constructor que heredan del objeto gen√©rico Object, la cual hace referencia a la funci√≥n  constructora que inicializa el objeto lo que en principio (ahora veremos por qu√© digo  esto) nos permite determinar la funci√≥n constructora de un objeto, y casi por extensi√≥n, la  clase de √©ste: 

```
function Cliente() { 
 // Definici√≥n de miembros de Cliente‚Ä¶ 
} 

var unCliente = new Cliente(); 

if (unCliente.constructor == Cliente) { 
 // Hacer algo con el objeto unCliente 
} 
```

Por otro lado, tambi√©n podr√≠amos utilizar el operador instanceof para determinar la  constructora de un objeto, pero con algunas diferencias. El operador instanceof , a  diferencia del anterior, comprueba la jerarqu√≠a del objeto, por lo tanto podr√≠amos  preguntar directamente sobre el objeto padre con id√©nticos resultados:   


```
unCliente instanceof Cliente // es true 
unCliente instanceof Object // es true 
```


Lamentablemente en JavaScript nada es tan sencillo como parece. Las cosas se complican  cuando hablamos de modificar el prototipo de un objeto y la propiedad constructor parece perder la referencia a la funci√≥n constructora.

## Uso del This para el p√∫blico y privado 

### ¬øQu√© es ‚Äúthis‚Äù (este)? 

Es posible que hayas notado algo un poco extra√±o en nuestros m√©todos.  Mira esto, por ejemplo: 

saludo: function() { 

 alert(‚Äò¬°Hola!, Soy ‚Äò+ this.nombre.pila + ‚Äò.‚Äô); 

} 

Probablemente te est√©s preguntando qu√© es ‚Äúthis‚Äù. La palabra clave this se refiere al  objeto actual en el que se est√° escribiendo el c√≥digo, por lo que en este caso this es  equivalente a la persona.  

Entonces, ¬øpor qu√© no escribir persona en su lugar? Como ver√°s en el art√≠culo JavaScript  orientado a objetos para principiantes cuando comenzaremos a crear constructores, etc.,  this es muy √∫til: siempre asegurar√° que se usen los valores correctos cuando cambie el  contexto de un miembro (por ejemplo, dos diferentes instancias de objetos persona)  pueden tener diferentes nombres, pero querr√°x usar su propio nombre al decir su saludo). 

Vamos a ilustrar lo que queremos decir con un par de objetos persona simplificados: 

```
var persona1 = { 
 nombre: ‚ÄòChris‚Äô, 
 saludo: function() { 
   alert(‚Äò¬°Hola!, Soy ‚Äò+ this.nombre + ‚Äò.‚Äô); 
 } 
} 

var persona2 = { 
 nombre: ‚ÄòBrian‚Äô, 
 saludo: function() { 
 alert(‚Äò¬°Hola!, Soy ‚Äò+ this.nombre + ‚Äò.‚Äô); 
 } 
} 

```

En este caso, persona1.saludo() mostrar√° ‚Äú¬°Hola!, Soy Chris‚Äù; persona2.saludo() por otro  lado mostrar√° ‚Äú¬°Hola!, Soy Brian‚Äù, aunque el c√≥digo del m√©todo es exactamente el mismo  en cada caso. Como dijimos antes, this es igual al objeto en el que est√° el c√≥digo; esto no  es muy √∫til cuando se escriben objetos literales a mano, pero realmente se vuelve √∫til  cuando se generan objetos din√°micamente (por ejemplo, usando constructores) Todo se  aclarar√° m√°s adelante.

this es un keyword de JavaScript que tiene un comportamiento muy diferente a otros  lenguajes de programaci√≥n, as√≠ para algunos es considerado uno de los grandes errores de  dise√±o del lenguaje. 

La clave para entender el comportamiento de this, es tener claro donde se invoca, para  saber qu√© objeto le asigna. 

¬øDonde se est√° invocando this? 

Asignaci√≥n impl√≠cita 

Caso 1 

En el primer caso this est√° siendo invocado dentro de un m√©todo. 
```
let yo = { 
 nombre: ‚Äòyeison‚Äô, 
 edad: 22, 
 hablar: function () { 
 console.log(this.nombre); 

 } 
}; 

yo.hablar(); // yeison 
```


this, hace referencia al objeto, que contiene el m√©todo donde se invoca.

Caso 2 

En este caso, existe una funci√≥n que recibe un objeto como par√°metro, y le agrega el  m√©todo hablar, luego, se ejecuta la funci√≥n sobre dos objetos. 

```
let decirNombre = function(obj) { 
 obj.hablar = function() { 
 console.log(this.nombre); 
 }; 
}; 

const Mateo = { 
 nombre: ‚ÄòMateo‚Äô, 
 edad: 22 
}; 

const juan = { 
 nombre: ‚ÄòJuan‚Äô, 
 edad: 25 

}; 

decirNombre(juan); 

decirNombre(Mateo); 

juan.hablar(); // Juan 

Mateo.hablar(); // Mateo ```


This en este caso hace referencia al objeto que se a√±ade este m√©todo.

Caso 3 

En este caso tenemos una funci√≥n que retorna un objeto, que contiene un m√©todo hablar,  que invoca this. 

```
let Persona = function (nombre, edad, madre) { 

 return { 
   nombre: nombre, 
   edad: edad, 
   hablar: function() { 
     console.log(this.nombre); 
  }, 

  madre: { 
   nombre: madre, 
   hablar: function() { 
   console.log(this.nombre); 
  } 

  } 
 }; 
}; 

const ana = Persona(‚ÄòAna‚Äô, 30, ‚ÄòClara‚Äô); 

ana.hablar(); // Ana 

ana.madre.hablar(); // Clara 
```


This en este caso hace referencia al objeto que contiene el m√©todo donde se invoca. Como vimos en los 3 casos, cuando this es invocado dentro de un m√©todo, impl√≠citamente  este hace referencia al objeto que contiene el m√©todo, sin importar si el m√©todo es  a√±adido luego de haber sido creado el objeto, o si es una funci√≥n que retorna un objeto.

### Asignaci√≥n expl√≠cita 

En el caso de asignaci√≥n impl√≠cita, this hace referencia al objeto, que conten√≠a el m√©todo  donde se invoca this, pero si tenemos una funci√≥n y deseamos expl√≠citamente asignarle a  que va a hacer referencia this, desde ES5 contamos con los m√©todos call(), apply() y bind(). Vamos a tener una funci√≥n, que reciba unos par√°metros y muestre en consola, con la  propiedad nombre a la que haga referencia this, y los par√°metros que recibe. 

```
const hablar = function(l1, l2, l3) { 

 console.log(`Hola mi nombre es ${this.nombre} 

 y se programar en ${l1}, ${l2}, ${l3}.`); 

}; 

const yeison = { 

 nombre: ‚ÄòYeison‚Äô, 

 edad: 22 

}; 

const lenguajes = [‚ÄòJavaScript‚Äô, ‚ÄòPython‚Äô, ‚ÄòC‚Äô] 
```

Ahora, nosotros debemos referenciar la variable yeison para que esta sea this. 

```call() ```


```hablar.call(yeison, lenguajes[0],lenguajes[1],lenguajes[2]); ```


El m√©todo call nos permite definir a que va a hacer referencia this, en su primer  par√°metro, los par√°metros siguientes son los par√°metros que recibe la funci√≥n. 

```apply()``` 


```hablar.apply(yeison, lenguajes); ```

El m√©todo apply, funciona igual que call, permitiendo referencia this en el primer  par√°metro, pero este nos permite pasar un array, como los par√°metros de la funcion. 

```bind()``` 

Este m√©todo funciona diferente a los anteriores, este nos devuelve una funci√≥n, en d√≥nde  this, hace referencia al objeto que pasamos en su par√°metro. 

const hablaYeison = hablar.bind(yeison, lenguajes[0],lenguajes[1],lenguajes[2]); hablaYeison(); 

Estos tres m√©todos nos permite hacer una referencia expl√≠cita, y tener claro el valor de  this, en la ejecuci√≥n.


### Asignaci√≥n con new 

Otro caso, es cuando invocamos this en un constructor , como el siguiente ejemplo: 

```
let Animal = function(color, nombre, tipo) { 

 this.color = color; 

 this.nombre = nombre; 

 this.tipo = tipo; 

} 
```


```
const bipa = new Animal(‚Äògris‚Äô, ‚ÄòBipa‚Äô, ‚ÄòFelino‚Äô); 
```

En este caso, this hace referencia al objeto que se instanciando



---
---
