# üìñ M√≥dulo 3 | Javascript

---

##  Unidad 1: Fundamentos

Temas:

Or√≠genes de la programaci√≥n

Lenguajes de programaci√≥n

Herramientas de desarrollo

Debugging

Sintaxis general

Variables y tipos de valores

Condicionales

Operadores de comparaci√≥n y l√≥gicos

Estructura de control

Propiedades de JavaScript

Sentencia break/continue y otras estructuras de control

Bucles

---
---

## :star:  Estructuras de Control

### Sintaxis general 

La sintaxis de un lenguaje de programaci√≥n se define como el conjunto de reglas que  deben seguirse al escribir el c√≥digo fuente de los programas para considerarse como  correctos para ese lenguaje de programaci√≥n. 

La sintaxis de JavaScript es muy similar a la de otros lenguajes de programaci√≥n como Java  y C. Las normas b√°sicas que definen la sintaxis de JavaScript son las siguientes: 

- **No se tienen en cuenta los espacios en blanco y las nuevas l√≠neas**: como sucede  con XHTML, el int√©rprete de JavaScript ignora cualquier espacio en blanco  sobrante, por lo que el c√≥digo se puede ordenar de forma adecuada para  entenderlo mejor (tabulando las l√≠neas, a√±adiendo espacios, creando nuevas  l√≠neas, etc.) 


- **Se distinguen las may√∫sculas y min√∫sculas**: al igual que sucede con la sintaxis de  las etiquetas y elementos XHTML. Sin embargo, si en una p√°gina XHTML se utilizan  indistintamente may√∫sculas y min√∫sculas, la p√°gina se visualiza correctamente,  siendo el √∫nico problema la no validaci√≥n de la p√°gina. En cambio, si en JavaScript  se intercambian may√∫sculas y min√∫sculas el script no funciona. 


- **No se define el tipo de las variables**: al crear una variable, no es necesario indicar  el tipo de dato que almacenar√°. De esta forma, una misma variable puede  almacenar diferentes tipos de datos durante la ejecuci√≥n del script. 


- **No es necesario terminar cada sentencia con el car√°cter de punto y coma (;)**: en  la mayor√≠a de lenguajes de programaci√≥n, es obligatorio terminar cada sentencia  con el car√°cter ;. Aunque JavaScript no obliga a hacerlo, es conveniente seguir la  tradici√≥n de terminar cada sentencia con el car√°cter del punto y coma (;). 


- **Se pueden incluir comentarios**: los comentarios se utilizan para a√±adir  informaci√≥n en el c√≥digo fuente del programa. Aunque el contenido de los  comentarios no se visualiza por pantalla, si que se env√≠a al navegador del usuario  junto con el resto del script, por lo que es necesario extremar las precauciones  sobre la informaci√≥n incluida en los comentarios.



### Variables 

Las variables en los lenguajes de programaci√≥n siguen una l√≥gica similar a las variables  utilizadas en otros √°mbitos como las matem√°ticas. Una variable es un elemento que se  emplea para almacenar y hacer referencia a otro valor. Gracias a las variables es posible  crear ‚Äúprogramas gen√©ricos‚Äù, es decir, programas que funcionan siempre igual  independientemente de los valores concretos utilizados. 

De la misma forma que si en Matem√°ticas no existieran las variables no se podr√≠an definir  las ecuaciones y f√≥rmulas, en programaci√≥n no se podr√≠an hacer programas realmente  √∫tiles sin las variables. 

Si no existieran variables, un programa que suma dos n√∫meros podr√≠a escribirse como: resultado = 3 + 1 

El programa anterior es tan poco √∫til que s√≥lo sirve para el caso en el que el primer  n√∫mero de la suma sea el 3 y el segundo n√∫mero sea el 1. En cualquier otro caso,  el programa obtiene un resultado incorrecto. 

Sin embargo, el programa se puede rehacer de la siguiente manera utilizando variables  para almacenar y referirse a cada n√∫mero: 

```JavaScript
numero_1 = 3 
numero_2 = 1 
resultado = numero_1 + numero_2 
```

Los elementos **numero_1** y **numero_2** son variables que almacenan los valores que utiliza  el programa. 

El resultado se calcula siempre en funci√≥n del valor almacenado por las  variables, por lo que este programa funciona correctamente para cualquier par de  n√∫meros indicado. 

Si se modifica el valor de las variables numero_1 y numero_2, el  programa sigue funcionando correctamente.

Las variables en JavaScript se crean mediante la palabra reservada var. De esta forma, el  ejemplo anterior se puede realizar en JavaScript de la siguiente manera: 

```JavaScript
var numero_1 = 3; 
var numero_2 = 1; 
var resultado = numero_1 + numero_2; 
```

La palabra reservada **var** solamente se debe indicar al definir por primera vez la variable,  lo que se denomina declarar una variable. Cuando se utilizan las variables en el resto de  instrucciones del script, solamente es necesario indicar su nombre. En otras palabras, en  el ejemplo anterior ser√≠a un error indicar lo siguiente: 

var numero_1 = 3; 

var numero_2 = 1; 

var resultado = var numero_1 + var numero_2; 

Si cuando se declara una variable se le asigna tambi√©n un valor, se dice que la variable ha  sido inicializada. En JavaScript no es obligatorio inicializar las variables, ya que se pueden  declarar por una parte y asignarles un valor posteriormente. Por tanto, el ejemplo anterior  se puede rehacer de la siguiente manera: 


```JavaScript
var numero_1; 
var numero_2; 
numero_1 = 3; 
numero_2 = 1; 
var resultado = numero_1 + numero_2;
```



Una de las caracter√≠sticas m√°s sorprendentes de JavaSript para los programadores  habituados a otros lenguajes de programaci√≥n es que tampoco es necesario declarar las  variables. En otras palabras, se pueden utilizar variables que no se han definido  anteriormente mediante la palabra reservada var. El ejemplo anterior tambi√©n es correcto  en JavaScript de la siguiente forma: 


```JavaScript
var numero_1 = 3; 
var numero_2 = 1; 
resultado = numero_1 + numero_2; 
```


La variable resultado no est√° declarada, por lo que JavaScript crea una variable global  (m√°s adelante se ver√°n las diferencias entre variables locales y globales) y le asigna el  valor correspondiente. De la misma forma, tambi√©n ser√≠a correcto el siguiente c√≥digo: 


```JavaScript
numero_1 = 3; 
numero_2 = 1; 
resultado = numero_1 + numero_2; 
```

En cualquier caso, se recomienda declarar todas las variables que se vayan a utilizar.

El nombre de una variable tambi√©n se conoce como identificador y debe cumplir las  siguientes normas: 

- S√≥lo puede estar formado por letras, n√∫meros y los s√≠mbolos $ (d√≥lar) y _ (gui√≥n bajo). 

- El primer car√°cter no puede ser un n√∫mero. 


Por tanto, las siguientes variables tienen nombres correctos: 

```JavaScript
var $numero1; 
var _$letra; 
var $$$otroNumero; 
var $_a__$4; 
```

Sin embargo, las siguientes variables tienen identificadores incorrectos: 

```JavaScript
var 1numero; // Empieza por un n√∫mero 
var numero;1_123; // Contiene un car√°cter ‚Äú;‚Äù
```


### Tipos de Valores 

Aunque todas las variables de JavaScript se crean de la misma forma (mediante la palabra  reservada var), la forma en la que se les asigna un valor depende del tipo de valor que se  quiere almacenar (n√∫meros, textos, etc.) 

#### Num√©ricos (Integers) 

Se utilizan para almacenar valores num√©ricos enteros (llamados **integer** en ingl√©s) o  decimales (llamados **float** en ingl√©s). 

En este caso, el valor se asigna indicando  directamente el n√∫mero entero o decimal. 

Los n√∫meros decimales utilizan el  car√°cter . (punto) en vez de , (coma) para separar la parte entera y la parte decimal: 


```JavaScript
var iva = 16; // variable tipo entero 
var total = 234.65; // variable tipo decimal 
```


#### Cadenas de texto (Strings) 

Se utilizan para almacenar caracteres, palabras y/o frases de texto. Para asignar el valor a  la variable, se encierra el valor entre comillas dobles o simples, para delimitar su comienzo  y su final: 


```JavaScript
var mensaje = ‚ÄúBienvenido a Academia Numen‚Äù; 
var nombreCurso = ‚ÄòDesarrollo Web Full Stack‚Äô; 
var letraSeleccionada = ‚ÄòA‚Äô;
```


En ocasiones, el texto que se almacena en las variables no es tan sencillo. Si por ejemplo el  propio texto contiene comillas simples o dobles, la estrategia que se sigue es la de  encerrar el texto con las comillas (simples o dobles) que no utilice el texto: 


```JavaScript
// El contenido de texto1 tiene comillas simples, por lo que se encierra con comillas dobles  
var texto1 = ‚ÄúUna frase con ‚Äòcomillas simples‚Äô dentro‚Äù; 

// El contenido de texto2 tiene comillas dobles, por lo que se encierra con comillas simples  
var texto2 = ‚ÄòUna frase con ‚Äúcomillas dobles‚Äù dentro‚Äô; 
```


No obstante, a veces las cadenas de texto contienen tanto comillas simples como dobles.  

Adem√°s, existen otros caracteres que son dif√≠ciles de incluir en una variable de texto  (tabulador, ENTER, etc.) Para resolver estos problemas, JavaScript define un mecanismo  para incluir de forma sencilla caracteres especiales y problem√°ticos dentro de una cadena  de texto. 

El mecanismo consiste en sustituir el car√°cter problem√°tico por una combinaci√≥n simple  de caracteres. A continuaci√≥n se muestra la tabla de conversi√≥n que se debe utilizar:


| Si se quiere incluir‚Ä¶ | Se debe incluir‚Ä¶ |
| --------------------- | ---------------- |
| Una nueva l√≠nea | 	```\n``` |
| Un tabulador 	| ```\t``` |
| Una comilla simple |	```\‚Äô``` |
| Una comilla doble  |	```\‚Äù``` |
|Una barra inclinada 	| ```\\``` |
 

De esta forma, el ejemplo anterior que conten√≠a comillas simples y dobles dentro del texto  se puede rehacer de la siguiente forma: 


```JavaScript
var texto1 = ‚ÄòUna frase con \‚Äôcomillas simples\‚Äô dentro‚Äô; 
var texto2 = ‚ÄúUna frase con \‚Äùcomillas dobles\‚Äù dentro‚Äù; 
```


Este mecanismo de JavaScript se denomina ‚Äúmecanismo de escape‚Äù de los caracteres  problem√°ticos, y es habitual referirse a que los caracteres han sido ‚Äúescapados‚Äù. 


#### Arrays 

En ocasiones, a los arrays se les llama vectores, matrices e incluso arreglos. No obstante,  el t√©rmino array es el m√°s utilizado y es una palabra com√∫nmente aceptada en el entorno  de la programaci√≥n. 

Un array es una colecci√≥n de variables, que pueden ser todas del mismo tipo o cada una  de un tipo diferente. Su utilidad se comprende mejor con un ejemplo sencillo: si una  aplicaci√≥n necesita manejar los d√≠as de la semana, se podr√≠an crear siete variables de tipo  texto: 


```JavaScripr
var dia1 = ‚ÄúLunes‚Äù; 
var dia2 = ‚ÄúMartes‚Äù; 
var dia7 = ‚ÄúDomingo‚Äù; 
```


Aunque el c√≥digo anterior no es incorrecto, s√≠ que es poco eficiente y complica en exceso  la programaci√≥n. Si en vez de los d√≠as de la semana se tuviera que guardar el nombre de  los meses del a√±o, el nombre de todos los pa√≠ses del mundo o las mediciones diarias de  temperatura de los √∫ltimos 100 a√±os, se tendr√≠an que crear decenas o cientos de  variables.

En este tipo de casos, se pueden agrupar todas las variables relacionadas en una colecci√≥n  de variables o array. El ejemplo anterior se puede rehacer de la siguiente forma: 

```var dias = [‚ÄúLunes‚Äù, ‚ÄúMartes‚Äù, ‚ÄúMi√©rcoles‚Äù, ‚ÄúJueves‚Äù, ‚ÄúViernes‚Äù, ‚ÄúS√°bado‚Äù, ‚ÄúDomingo‚Äù]; ```

Ahora, una √∫nica variable llamada dias almacena todos los valores relacionados entre s√≠,  en este caso los d√≠as de la semana. Para definir un array, se utilizan los caracteres [ y ] para  delimitar su comienzo y su final y se utiliza el car√°cter , (coma) para separar sus  elementos: 

```var nombre_array = [valor1, valor2, ‚Ä¶, valorN]; ```

Una vez definido un array, es muy sencillo acceder a cada uno de sus elementos. Cada  elemento se accede indicando su posici√≥n dentro del array. La √∫nica complicaci√≥n, que es  responsable de muchos errores cuando se empieza a programar, es que las posiciones de  los elementos empiezan a contarse en el 0 y no en el 1: 

```var diaSeleccionado = dias[0]; // diaSeleccionado = ‚ÄúLunes‚Äù ```

```var otroDia = dias[5]; // otroDia = ‚ÄúS√°bado‚Äù ```

En el ejemplo anterior, la primera instrucci√≥n quiere obtener el primer elemento del  array. Para ello, se indica el nombre del array y entre corchetes la posici√≥n del elemento  dentro del array. Como se ha comentado, las posiciones se empiezan a contar en el 0, por  lo que el primer elemento ocupa la posici√≥n 0 y se accede a el mediante dias[0]. 

El valor dias[5] hace referencia al elemento que ocupa la sexta posici√≥n dentro del  array dias. Como las posiciones empiezan a contarse en 0, la posici√≥n 5 hace referencia al  sexto elemento, en este caso, el valor S√°bado.


### Booleanos 

Las variables de tipo boolean o booleano tambi√©n se conocen con el nombre de variables  de tipo l√≥gico. Su funcionamiento b√°sico es muy sencillo. 

Una variable de tipo boolean almacena un tipo especial de valor que solamente puede  tomar dos valores: true (verdadero) o false (falso). No se puede utilizar para almacenar  n√∫meros y tampoco permite guardar cadenas de texto. 

Los √∫nicos valores que pueden almacenar estas variables son true y false, por lo que no  pueden utilizarse los valores verdadero y falso. A continuaci√≥n se muestra un par de  variables de tipo booleano: 


```JavaScript
var clienteRegistrado = false; 
var ivaIncluido = true;
```


#### Operadores 

Las variables por s√≠ solas son de poca utilidad. Hasta ahora, s√≥lo se ha visto c√≥mo crear  variables de diferentes tipos y c√≥mo mostrar su valor mediante la funci√≥n alert(). Para  hacer programas realmente √∫tiles, son necesarias otro tipo de herramientas. 

Los operadores permiten manipular el valor de las variables, realizar operaciones matem√°ticas con sus valores y comparar diferentes variables. De esta forma, los  operadores permiten a los programas realizar c√°lculos complejos y tomar decisiones  l√≥gicas en funci√≥n de comparaciones y otros tipos de condiciones. 

#### Incremento y Decremento 

Estos dos operadores solamente son v√°lidos para las variables num√©ricas y se utilizan para  incrementar o decrementar en una unidad el valor de una variable. 

Ejemplo: 

```JavaScript
var numero = 5; 
++numero; 
alert(numero); // numero = 6 
```


El operador de incremento se indica mediante el prefijo ++ en el nombre de la variable. El  resultado es que el valor de esa variable se incrementa en una unidad. Por tanto, el  anterior ejemplo es equivalente a: 


```JavaScript
var numero = 5; 
numero = numero + 1; 
alert(numero); // numero = 6
```


De forma equivalente, el operador decremento (indicado como un prefijo ‚Äî en el nombre  de la variable) se utiliza para decrementar el valor de la variable: 


```JavaScript
var numero = 5; 
‚Äînumero; 
alert(numero); // numero = 4 
```


El anterior ejemplo es equivalente a: 

```JavaScript
var numero = 5; 
numero = numero ‚Äì 1; 
alert(numero); // numero = 4 
```


Los operadores de incremento y decremento no solamente se pueden indicar como  prefijo del nombre de la variable, sino que tambi√©n es posible utilizarlos como sufijo. En  este caso, su comportamiento es similar pero muy diferente. En el siguiente ejemplo: 


```JavaScript
var numero = 5; 
numero++; 
alert(numero); // numero = 6 
```


El resultado de ejecutar el script anterior es el mismo que cuando se utiliza el  operador ++numero, por lo que puede parecer que es equivalente indicar el  operador ++ delante o detr√°s del identificador de la variable. 

Sin embargo, el siguiente ejemplo muestra sus diferencias: 


```JavaScript
var numero1 = 5; 
var numero2 = 2; 
numero3 = numero1++ + numero2; 
// numero3 = 7, numero1 = 6 
var numero1 = 5; 
var numero2 = 2; 
numero3 = ++numero1 + numero2; 
// numero3 = 8, numero1 = 6 
```



Si el operador ++ se indica como prefijo del identificador de la variable, su valor se  incrementa antes de realizar cualquier otra operaci√≥n. Si el operador ++ se indica como  sufijo del identificador de la variable, su valor se incrementa despu√©s de ejecutar la  sentencia en la que aparece. 

Por tanto, en la instrucci√≥n numero3 = numero1++ + numero2;, el valor de numero1 se  incrementa despu√©s de realizar la operaci√≥n (primero se suma y numero3 vale 7, despu√©s  se incrementa el valor de numero1 y vale 6). Sin embargo, en la instrucci√≥n numero3 =  ++numero1 + numero2;, en primer lugar se incrementa el valor de numero1 y despu√©s se  realiza la suma (primero se incrementa numero1 y vale 6, despu√©s se realiza la suma  y numero3 vale 8).


#### Negaci√≥n (!) 

Uno de los operadores l√≥gicos m√°s utilizados es el de la negaci√≥n. Se utiliza para obtener  el valor contrario al valor de la variable: 


```JavaScript
var visible = true; 
alert(!visible); // Muestra ‚Äúfalse‚Äù y no ‚Äútrue‚Äù 
```


La negaci√≥n l√≥gica se obtiene prefijando el s√≠mbolo ! al identificador de la variable. El  funcionamiento de este operador se resume en la siguiente tabla: 

| variable |	!variable |
| -------- | ------------ |
| true |	false |
| false 	| true |
 

Si la variable original es de tipo booleano, es muy sencillo obtener su negaci√≥n. Sin  embargo, ¬øqu√© sucede cuando la variable es un n√∫mero o una cadena de texto? Para  obtener la negaci√≥n en este tipo de variables, se realiza en primer lugar su conversi√≥n a un  valor booleano: 

- Si la variable contiene un n√∫mero, se transforma en false si vale 0 y en true para  cualquier otro n√∫mero (positivo o negativo, decimal o entero). 

- Si la variable contiene una cadena de texto, se transforma en false si la cadena es  vac√≠a (‚Äú‚Äù) y en true en cualquier otro caso. 


```JavaScript
var cantidad = 0; 
vacio = !cantidad; // vacio = true 
cantidad = 2; 
vacio = !cantidad; // vacio = false
var mensaje = ‚Äú‚Äù; 
mensajeVacio = !mensaje; // mensajeVacio = true 
mensaje = ‚ÄúBienvenido‚Äù; 
mensajeVacio = !mensaje; // mensajeVacio = false 
```


# ### AND (&&) 

La operaci√≥n l√≥gica AND obtiene su resultado combinando dos valores booleanos. El  operador se indica mediante el s√≠mbolo && y su resultado solamente es true si los dos  operandos son true: 


```
variable1    variable2 	variable1 && variable2
true 	       true 	  true
true 	       false 	  false
false 	       true 	  false
false 	       false 	  false
``` 

```JavaScript
var valor1 = true; 
var valor2 = false; 
resultado = valor1 && valor2; // resultado = false 
valor1 = true; 
valor2 = true; 
resultado = valor1 && valor2; // resultado = true
```


#### OR (||) 

La operaci√≥n l√≥gica OR tambi√©n combina dos valores booleanos. El operador se indica  mediante el s√≠mbolo || y su resultado es true si alguno de los dos operandos es true: 


```
variable1  variable2 	variable1 || variable2
true 	   true 	 true
true 	   false 	 true
false 	   true 	 true
false 	   false 	 false
```


```JavaScript 
var valor1 = true; 
var valor2 = false; 
resultado = valor1 || valor2; // resultado = true 
valor1 = false; 
valor2 = false; 
resultado = valor1 || valor2; // resultado = false
```


#### Matem√°ticos 

JavaScript permite realizar manipulaciones matem√°ticas sobre el valor de las variables  num√©ricas. Los operadores definidos son: suma (```+```), resta (```‚Äì```), multiplicaci√≥n (```*```) y divisi√≥n  (```/```). Ejemplo: 


```JavaScript
var numero1 = 10; 
var numero2 = 5; 
resultado = numero1 / numero2; // resultado = 2 
resultado = 3 + numero1; // resultado = 13 
resultado = numero2 ‚Äì 4; // resultado = 1 
resultado = numero1 * numero 2; // resultado = 50 
```


Adem√°s de los cuatro operadores b√°sicos, JavaScript define otro operador matem√°tico  que no es sencillo de entender cuando se estudia por primera vez, pero que es muy √∫til en  algunas ocasiones. 

Se trata del operador ‚Äúm√≥dulo‚Äù, que calcula el resto de la divisi√≥n entera de dos n√∫meros.  Si se divide por ejemplo 10 y 5, la divisi√≥n es exacta y da un resultado de 2. El resto de esa  divisi√≥n es 0, por lo que m√≥dulo de 10 y 5 es igual a 0. 

Sin embargo, si se divide 9 y 5, la divisi√≥n no es exacta, el resultado es 1 y el resto 4, por lo  que m√≥dulo de 9 y 5 es igual a 4. 

El operador m√≥dulo en JavaScript se indica mediante el s√≠mbolo %, que no debe  confundirse con el c√°lculo del porcentaje: 


```JavaScript
var numero1 = 10; 
var numero2 = 5; 
resultado = numero1 % numero2; // resultado = 0
numero1 = 9; 
numero2 = 5; 
resultado = numero1 % numero2; // resultado = 4 
```


Los operadores matem√°ticos tambi√©n se pueden combinar con el operador de asignaci√≥n  para abreviar su notaci√≥n: 


```JavaScript
var numero1 = 5; 
numero1 += 3; // numero1 = numero1 + 3 = 8 
numero1 -= 1; // numero1 = numero1 ‚Äì 1 = 4 
numero1 *= 2; // numero1 = numero1 * 2 = 10 
numero1 /= 5; // numero1 = numero1 / 5 = 1 
numero1 %= 4; // numero1 = numero1 % 4 = 1
```


#### Relacionales 

Los operadores relacionales definidos por JavaScript son id√©nticos a los que definen las  matem√°ticas: mayor que (```>```), menor que (```<```), mayor o igual (```>=```), menor o igual (```<=```), igual  que (```==```) y distinto de (```!=```). 

Los operadores que relacionan variables son imprescindibles para realizar cualquier  aplicaci√≥n compleja, como se ver√° en el siguiente cap√≠tulo de programaci√≥n avanzada. El  resultado de todos estos operadores siempre es un valor booleano: 


```JavaScript
var numero1 = 3; 
var numero2 = 5; 
resultado = numero1 > numero2; // resultado = false 
resultado = numero1 < numero2; // resultado = true 
numero1 = 5; 
numero2 = 5; 
resultado = numero1 >= numero2; // resultado = true 
resultado = numero1 <= numero2; // resultado = true 
resultado = numero1 == numero2; // resultado = true 
resultado = numero1 != numero2; // resultado = false
```

Se debe tener especial cuidado con el operador de igualdad (==), ya que es el origen de la  mayor√≠a de errores de programaci√≥n, incluso para los usuarios que ya tienen cierta  experiencia desarrollando scripts. El operador == se utiliza para comparar el valor de dos  variables, por lo que es muy diferente del operador =, que se utiliza para asignar un valor a  una variable: 

```// El operador ‚Äú=‚Äù asigna valores ```

```JavaScript
var numero1 = 5; 
resultado = numero1 = 3; // numero1 = 3 y resultado = 3 
```


```// El operador ‚Äú==‚Äù compara variables ```


```JavaScript
var numero1 = 5; 
resultado = numero1 == 3; // numero1 = 5 y resultado = false 
```


Los operadores relacionales tambi√©n se pueden utilizar con variables de tipo cadena de  texto: 

```JavaScript
var texto1 = ‚Äúhola‚Äù; 
var texto2 = ‚Äúhola‚Äù; 
var texto3 = ‚Äúadios‚Äù;
resultado = texto1 == texto3; // resultado = false 
resultado = texto1 != texto2; // resultado = false 
resultado = texto3 >= texto2; // resultado = false 
```

Cuando se utilizan cadenas de texto, los operadores ‚Äúmayor que‚Äù (```>```) y ‚Äúmenor que‚Äù (```<```)  siguen un razonamiento no intuitivo: se compara letra a letra comenzando desde la  izquierda hasta que se encuentre una diferencia entre las dos cadenas de texto. Para  determinar si una letra es mayor o menor que otra, las may√∫sculas se consideran menores  que las min√∫sculas y las primeras letras del alfabeto son menores que las √∫ltimas (a es  menor que b, b es menor que c, A es menor que a, etc.)


#### Condicionales y Estructuras de Control 

Los programas que se pueden realizar utilizando solamente variables y operadores son  una simple sucesi√≥n lineal de instrucciones b√°sicas. 

Sin embargo, no se pueden realizar programas que muestren un mensaje si el valor de una  variable es igual a un valor determinado y no muestren el mensaje en el resto de casos.  Tampoco se puede repetir de forma eficiente una misma instrucci√≥n, como por ejemplo  sumar un determinado valor a todos los elementos de un array. 

Para realizar este tipo de programas son necesarias las estructuras de control de flujo,  que son instrucciones del tipo ‚Äúsi se cumple esta condici√≥n, hazlo; si no se cumple, haz esto  otro‚Äù. Tambi√©n existen instrucciones del tipo ‚Äúrepite esto mientras se cumpla esta  condici√≥n‚Äù. 

Si se utilizan estructuras de control de flujo, los programas dejan de ser una sucesi√≥n  lineal de instrucciones para convertirse en programas inteligentes que pueden tomar  decisiones en funci√≥n del valor de las variables. 

Estructura If 

La estructura m√°s utilizada en JavaScript y en la mayor√≠a de lenguajes de programaci√≥n es  la estructura if. Se emplea para tomar decisiones en funci√≥n de una condici√≥n. Su  definici√≥n formal es: 

```
if(condicion) { 
 ‚Ä¶ 
} 
```

Si la condici√≥n se cumple (es decir, si su valor es true) se ejecutan todas las instrucciones  que se encuentran dentro de {‚Ä¶}. Si la condici√≥n no se cumple (es decir, si su valor  es false) no se ejecuta ninguna instrucci√≥n contenida en {‚Ä¶} y el programa contin√∫a  ejecutando el resto de instrucciones del script. 

Ejemplo: 


```JavaScript
var mostrarMensaje = true;

if(mostrarMensaje) { 
 alert(‚ÄúHola Mundo‚Äù); 
} 
```

En el ejemplo anterior, el mensaje s√≠ que se muestra al usuario ya que la  variable mostrarMensaje tiene un valor de true y por tanto, el programa entra dentro del  bloque de instrucciones del if. 

El ejemplo se podr√≠a reescribir tambi√©n como: 


```JavaScript
var mostrarMensaje = true; 

if(mostrarMensaje == true) { 
 alert(‚ÄúHola Mundo‚Äù); 
} 
```

En este caso, la condici√≥n es una comparaci√≥n entre el valor de la  

variable mostrarMensaje y el valor true. Como los dos valores coinciden, la igualdad se  cumple y por tanto la condici√≥n es cierta, su valor es true y se ejecutan las instrucciones  contenidas en ese bloque del if.

La comparaci√≥n del ejemplo anterior suele ser el origen de muchos errores de  programaci√≥n, al confundir los operadores == y =. Las comparaciones siempre se realizan  con el operador ==, ya que el operador = solamente asigna valores: 


```
var mostrarMensaje = true; 

// Se comparan los dos valores 

if(mostrarMensaje == false) { 
 ‚Ä¶ 
} 
```


```
// Error ‚Äì Se asigna el valor ‚Äúfalse‚Äù a la variable 

if(mostrarMensaje = false) { 
 ‚Ä¶ 
} 
```

La condici√≥n que controla el if() puede combinar los diferentes operadores l√≥gicos y  relacionales mostrados anteriormente: 

```
var mostrado = false;

if(!mostrado) { 
 alert(‚ÄúEs la primera vez que se muestra el mensaje‚Äù); 
} 
```

Los operadores AND y OR permiten encadenar varias condiciones simples para construir  condiciones complejas: 


```JavaScript
var mostrado = false; 

var usuarioPermiteMensajes = true; 

if(!mostrado && usuarioPermiteMensajes) { 
 alert(‚ÄúEs la primera vez que se muestra el mensaje‚Äù); 
} 
```

La condici√≥n anterior est√° formada por una operaci√≥n AND sobre dos variables. A su vez, a  la primera variable se le aplica el operador de negaci√≥n antes de realizar la  operaci√≥n AND. De esta forma, como el valor de mostrado es false, el  valor !mostrado ser√≠a true. Como la variable usuarioPermiteMensajes vale true, el  resultado de !mostrado && usuarioPermiteMensajes ser√≠a igual a true && true, por lo que  el resultado final de la condici√≥n del if() ser√≠a true y por tanto, se ejecutan las  instrucciones que se encuentran dentro del bloque del if().

#### Estructura If ‚Ä¶ else 

En ocasiones, las decisiones que se deben realizar no son del tipo ‚Äúsi se cumple la  condici√≥n, hazlo; si no se cumple, no hagas nada‚Äù. Normalmente las condiciones suelen  ser del tipo ‚Äúsi se cumple esta condici√≥n, hazlo; si no se cumple, haz esto otro‚Äù. 

Para este segundo tipo de decisiones, existe una variante de la  

estructura if llamada if‚Ä¶else. Su definici√≥n formal es la siguiente: 


```
if(condicion) { 
 ‚Ä¶ 
} else { 
 ‚Ä¶ 
} 
```


Si la condici√≥n se cumple (es decir, si su valor es true) se ejecutan todas las instrucciones  que se encuentran dentro del if(). Si la condici√≥n no se cumple (es decir, si su valor  es false) se ejecutan todas las instrucciones contenidas en else { }. 

Ejemplo: 


```JavaScript
var edad = 18;

if(edad >= 18) { 
 alert(‚ÄúEres mayor de edad‚Äù); 
} else { 
 alert(‚ÄúTodav√≠a eres menor de edad‚Äù); 
} 
```

Si el valor de la variable edad es mayor o igual que el valor num√©rico 18, la condici√≥n del if() se cumple y por tanto, se ejecutan sus instrucciones y se muestra el mensaje ‚ÄúEres  mayor de edad‚Äù. Sin embargo, cuando el valor de la variable edad no es igual o mayor  que 18, la condici√≥n del if() no se cumple, por lo que autom√°ticamente se ejecutan todas  las instrucciones del bloque else { }. En este caso, se mostrar√≠a el mensaje ‚ÄúTodav√≠a eres  menor de edad‚Äù. 

El siguiente ejemplo compara variables de tipo cadena de texto: 


```JavaScript
var nombre = ‚Äú‚Äù; 

if(nombre == ‚Äú‚Äù) { 
 alert(‚ÄúA√∫n no nos has dicho tu nombre‚Äù); 
} else { 
 alert(‚ÄúHemos guardado tu nombre‚Äù); 
}
```



La condici√≥n del if() anterior se construye mediante el operador ==, que es el que se  emplea para comparar dos valores (no confundir con el operador = que se utiliza para  asignar valores). En el ejemplo anterior, si la cadena de texto almacenada en la  variable nombre es vac√≠a (es decir, es igual a ‚Äú‚Äù) se muestra el mensaje definido en el if().  En otro caso, se muestra el mensaje definido en el bloque else { }. 

La estructura if‚Ä¶else se puede encadenar para realizar varias comprobaciones seguidas: 

```
if(edad < 12) { 
 alert(‚ÄúTodav√≠a eres muy peque√±o‚Äù); 
}  else if(edad < 19) { 
 alert(‚ÄúEres un adolescente‚Äù); 
} else if(edad < 35) { 
 alert(‚ÄúAun sigues siendo joven‚Äù); 
} else { 
 alert(‚ÄúPiensa en cuidarte un poco m√°s‚Äù); 
} 
```

No es obligatorio que la combinaci√≥n de estructuras if‚Ä¶else acabe con la instrucci√≥n else,  ya que puede terminar con una instrucci√≥n de tipo else if().

#### Estructura for 

Las estructuras if y if‚Ä¶else no son muy eficientes cuando se desea ejecutar de forma  repetitiva una instrucci√≥n. Por ejemplo, si se quiere mostrar un mensaje cinco veces, se  podr√≠a pensar en utilizar el siguiente if: 


```JavaScript
var veces = 0; 

if(veces < 4) { 
 alert(‚ÄúMensaje‚Äù); 
 veces++; 
} 
```

Se comprueba si la variable veces es menor que 4. Si se cumple, se entra dentro del if(), se  muestra el mensaje y se incrementa el valor de la variable veces. As√≠ se deber√≠a seguir  ejecutando hasta mostrar el mensaje las cinco veces deseadas. 

Sin embargo, el funcionamiento real del script anterior es muy diferente al deseado, ya  que solamente se muestra una vez el mensaje por pantalla. La raz√≥n es que la ejecuci√≥n  de la estructura if() no se repite y la comprobaci√≥n de la condici√≥n s√≥lo se realiza una vez,  independientemente de que dentro del if() se modifique el valor de la variable utilizada en  la condici√≥n. 

La estructura for permite realizar este tipo de repeticiones (tambi√©n llamadas bucles) de  una forma muy sencilla. No obstante, su definici√≥n formal no es tan sencilla como la  de if(): 

```
for(inicializacion; condicion; actualizacion) { 
 ‚Ä¶ 
}
```

La idea del funcionamiento de un bucle for es la siguiente: ‚Äúmientras la condici√≥n indicada  se siga cumpliendo, repite la ejecuci√≥n de las instrucciones definidas dentro del for.  Adem√°s, despu√©s de cada repetici√≥n, actualiza el valor de las variables que se utilizan en la  condici√≥n‚Äù. 


- La ‚Äúinicializaci√≥n‚Äù es la zona en la que se establece los valores iniciales de las  variables que controlan la repetici√≥n. 

- La ‚Äúcondici√≥n‚Äù es el √∫nico elemento que decide si continua o se detiene la  repetici√≥n. 

- La ‚Äúactualizaci√≥n‚Äù es el nuevo valor que se asigna despu√©s de cada repetici√≥n a las  variables que controlan la repetici√≥n. 


```JavaScript
var mensaje = ‚ÄúHola, estoy dentro de un bucle‚Äù; 

for(var i = 0; i < 5; i++) { 
 alert(mensaje); 
} 
```

La parte de la inicializaci√≥n del bucle consiste en: 

```var i = 0;``` 

Por tanto, en primer lugar se crea la variable i y se le asigna el valor de 0. Esta zona de  inicializaci√≥n solamente se tiene en consideraci√≥n justo antes de comenzar a ejecutar el  bucle. Las siguientes repeticiones no tienen en cuenta esta parte de inicializaci√≥n. 

La zona de condici√≥n del bucle es: 

```i < 5``` 

Los bucles se siguen ejecutando mientras se cumplan las condiciones y se dejan de  ejecutar justo despu√©s de comprobar que la condici√≥n no se cumple. En este caso,  mientras la variable i valga menos de 5 el bucle se ejecuta indefinidamente.

Como la variable i se ha inicializado a un valor de 0 y la condici√≥n para salir del bucle es  que i sea menor que 5, si no se modifica el valor de i de alguna forma, el bucle se repetir√≠a  indefinidamente. 

Por ese motivo, es imprescindible indicar la zona de actualizaci√≥n, en la que se modifica el  valor de las variables que controlan el bucle: 

```i++ ```

En este caso, el valor de la variable i se incrementa en una unidad despu√©s de cada  repetici√≥n. La zona de actualizaci√≥n se ejecuta despu√©s de la ejecuci√≥n de las instrucciones  que incluye el for. 

As√≠, durante la ejecuci√≥n de la quinta repetici√≥n el valor de i ser√° 4. Despu√©s de la quinta  ejecuci√≥n, se actualiza el valor de i, que ahora valdr√° 5. Como la condici√≥n es que i sea  menor que 5, la condici√≥n ya no se cumple y las instrucciones del for no se ejecutan una  sexta vez. 

Normalmente, la variable que controla los bucles for se llama i, ya que recuerda a la  palabra √≠ndice y su nombre tan corto ahorra mucho tiempo y espacio. 

El ejemplo anterior que mostraba los d√≠as de la semana contenidos en un array se puede  rehacer de forma m√°s sencilla utilizando la estructura for: 


```JavaScript
var dias = [‚ÄúLunes‚Äù, ‚ÄúMartes‚Äù, ‚ÄúMi√©rcoles‚Äù, ‚ÄúJueves‚Äù, ‚ÄúViernes‚Äù, ‚ÄúS√°bado‚Äù, ‚ÄúDomingo‚Äù]; 

for(var i=0; i<7; i++) { 
 alert(dias[i]); 
}
```


#### Estructura for ‚Ä¶ in 

Una estructura de control derivada de for es la estructura for‚Ä¶in. Su definici√≥n exacta  implica el uso de objetos, que es un elemento de programaci√≥n avanzada que no se va a  estudiar. Por tanto, solamente se va a presentar la estructura for‚Ä¶in adaptada a su uso en  arrays. Su definici√≥n formal adaptada a los arrays es: 


```
for(indice in array) { 
 ‚Ä¶ 
} 
```

Si se quieren recorrer todos los elementos que forman un array, la estructura for‚Ä¶in es la  forma m√°s eficiente de hacerlo, como se muestra en el siguiente ejemplo: 


```JavaScript
var dias = [‚ÄúLunes‚Äù, ‚ÄúMartes‚Äù, ‚ÄúMi√©rcoles‚Äù, ‚ÄúJueves‚Äù, ‚ÄúViernes‚Äù, ‚ÄúS√°bado‚Äù, ‚ÄúDomingo‚Äù]; 

for(i in dias) { 
 alert(dias[i]); 
} 
```

La variable que se indica como indice es la que se puede utilizar dentro del  bucle for‚Ä¶in para acceder a los elementos del array. De esta forma, en la primera  repetici√≥n del bucle la variable i vale 0 y en la √∫ltima vale 6. 

Esta estructura de control es la m√°s adecuada para recorrer arrays (y objetos), ya que  evita tener que indicar la inicializaci√≥n y las condiciones del bucle for simple y funciona  correctamente cualquiera que sea la longitud del array. De hecho, sigue funcionando igual  aunque var√≠e el n√∫mero de elementos del array.

#### Propiedades de JavaScript 

- JavaScript incorpora una serie de herramientas y utilidades para el manejo de las  variables. De esta forma, muchas de las operaciones b√°sicas con las variables, se pueden  realizar directamente con las utilidades que ofrece JavaScript. 

- Funciones √∫tiles para cadenas de Texto 

A continuaci√≥n se muestran algunas de las funciones m√°s √∫tiles para el manejo de  cadenas de texto: 

- **length**, calcula la longitud de una cadena de texto (el n√∫mero de caracteres que la forman) 

```JavaScript
var mensaje = ‚ÄúHola Mundo‚Äù; 
var numeroLetras = mensaje.length; // numeroLetras = 10 
```

- **+**, se emplea para concatenar varias cadenas de texto :

```JavaScript
var mensaje1 = ‚ÄúHola‚Äù; 
var mensaje2 = ‚Äù Mundo‚Äù; 
var mensaje = mensaje1 + mensaje2; // mensaje = ‚ÄúHola Mundo‚Äù 
```

Adem√°s del operador +, tambi√©n se puede utilizar la funci√≥n **concat()**:

```JavaScript
var mensaje1 = ‚ÄúHola‚Äù; 
var mensaje2 = mensaje1.concat(‚Äù Mundo‚Äù); // mensaje2 = ‚ÄúHola Mundo‚Äù
```

- Las cadenas de texto tambi√©n se pueden unir con variables num√©ricas: 

```JavaScript
var variable1 = ‚ÄúHola ‚Äú; 
var variable2 = 3; 
var mensaje = variable1 + variable2; // mensaje = ‚ÄúHola 3‚Äù 
```

- Cuando se unen varias cadenas de texto es habitual olvidar a√±adir un espacio de  separaci√≥n entre las palabras: 

```JavaScript
var mensaje1 = ‚ÄúHola‚Äù; 
var mensaje2 = ‚ÄúMundo‚Äù; 
var mensaje = mensaje1 + mensaje2; // mensaje = ‚ÄúHolaMundo‚Äù 
```

- Los espacios en blanco se pueden a√±adir al final o al principio de las cadenas y tambi√©n se  pueden indicar forma expl√≠cita: 

```JavaScript
var mensaje1 = ‚ÄúHola‚Äù; 
var mensaje2 = ‚ÄúMundo‚Äù; 
var mensaje = mensaje1 + ‚Äù ‚Äù + mensaje2; // mensaje = ‚ÄúHola Mundo‚Äù 
```

- **toUpperCase()**, transforma todos los caracteres de la cadena a sus correspondientes  caracteres en may√∫sculas: 


```JavaScript
var mensaje1 = ‚ÄúHola‚Äù; 
var mensaje2 = mensaje1.toUpperCase(); // mensaje2 = ‚ÄúHOLA‚Äù
```

- **toLowerCase()**, transforma todos los caracteres de la cadena a sus correspondientes  caracteres en min√∫sculas: 

```JavaScript
var mensaje1 = ‚ÄúHolA‚Äù; 
var mensaje2 = mensaje1.toLowerCase(); // mensaje2 = ‚Äúhola‚Äù 
```

- **charAt(posicion)**, obtiene el car√°cter que se encuentra en la posici√≥n indicada: var mensaje = ‚ÄúHola‚Äù; 

```JavaScript
var letra = mensaje.charAt(0); // letra = H 
letra = mensaje.charAt(2); // letra = l 
```

- **indexOf(caracter)**, calcula la posici√≥n en la que se encuentra el car√°cter indicado dentro de  la cadena de texto. Si el car√°cter se incluye varias veces dentro de la cadena de texto, se  devuelve su primera posici√≥n empezando a buscar desde la izquierda. Si la cadena no  contiene el car√°cter, la funci√≥n devuelve el valor -1: 

```JavaScript
var mensaje = ‚ÄúHola‚Äù; 
var posicion = mensaje.indexOf(‚Äòa‚Äô); // posicion = 3 
posicion = mensaje.indexOf(‚Äòb‚Äô); // posicion = -1 
```

Su funci√≥n an√°loga es **lastIndexOf()**: 

- **lastIndexOf(caracter)**, calcula la √∫ltima posici√≥n en la que se encuentra el car√°cter  indicado dentro de la cadena de texto. Si la cadena no contiene el car√°cter, la funci√≥n  devuelve el valor -1: 


```JavaScript
var mensaje = ‚ÄúHola‚Äù; 
var posicion = mensaje.lastIndexOf(‚Äòa‚Äô); // posicion = 3 
posicion = mensaje.lastIndexOf(‚Äòb‚Äô); // posicion = -1
```

La funci√≥n lastIndexOf() comienza su b√∫squeda desde el final de la cadena hacia el  principio, aunque la posici√≥n devuelta es la correcta empezando a contar desde el  principio de la palabra. 

- **substring(inicio, final)**, extrae una porci√≥n de una cadena de texto. El segundo par√°metro  es opcional. Si s√≥lo se indica el par√°metro inicio, la funci√≥n devuelve la parte de la cadena  original correspondiente desde esa posici√≥n hasta el final: 


```JavaScript
var mensaje = ‚ÄúHola Mundo‚Äù; 
var porcion = mensaje.substring(2); // porcion = ‚Äúla Mundo‚Äù 
porcion = mensaje.substring(5); // porcion = ‚ÄúMundo‚Äù 
porcion = mensaje.substring(7); // porcion = ‚Äúndo‚Äù 
```

Si se indica un inicio negativo, se devuelve la misma cadena original: 

```JavaScript
var mensaje = ‚ÄúHola Mundo‚Äù; 
var porcion = mensaje.substring(-2); // porcion = ‚ÄúHola Mundo‚Äù 
```

Cuando se indica el inicio y el final, se devuelve la parte de la cadena original comprendida  entre la posici√≥n inicial y la inmediatamente anterior a la posici√≥n final (es decir, la  posici√≥n inicio est√° incluida y la posici√≥n final no): 


```JavaScript
var mensaje = ‚ÄúHola Mundo‚Äù; 
var porcion = mensaje.substring(1, 8); // porcion = ‚Äúola Mun‚Äù 
porcion = mensaje.substring(3, 4); // porcion = ‚Äúa‚Äù
```

Si se indica un final m√°s peque√±o que el inicio, JavaScript los considera de forma inversa,  ya que autom√°ticamente asigna el valor m√°s peque√±o al inicio y el m√°s grande al final: 

```JavaScript
var mensaje = ‚ÄúHola Mundo‚Äù; 
var porcion = mensaje.substring(5, 0); // porcion = ‚ÄúHola ‚Äù 
porcion = mensaje.substring(0, 5); // porcion = ‚ÄúHola ‚Äù 
```

- **split(separador)**, convierte una cadena de texto en un array de cadenas de texto. La  funci√≥n parte la cadena de texto determinando sus trozos a partir del  car√°cter separador indicado: 


```JavaScript
var mensaje = ‚ÄúHola Mundo, soy una cadena de texto!‚Äù; 
var palabras = mensaje.split(‚Äù ‚Äú); 
// palabras = [‚ÄúHola‚Äù, ‚ÄúMundo,‚Äù, ‚Äúsoy‚Äù, ‚Äúuna‚Äù, ‚Äúcadena‚Äù, ‚Äúde‚Äù, ‚Äútexto!‚Äù]; 
```

Con esta funci√≥n se pueden extraer f√°cilmente las letras que forman una palabra: 

```JavaScript
var palabra = ‚ÄúHola‚Äù; 
var letras = palabra.split(‚Äú‚Äù); // letras = [‚ÄúH‚Äù, ‚Äúo‚Äù, ‚Äúl‚Äù, ‚Äúa‚Äù]
```


#### Funciones √∫tiles para Arrays 

A continuaci√≥n se muestran algunas de las funciones m√°s √∫tiles para el manejo de arrays: 

- **length**, calcula el n√∫mero de elementos de un array 


```JavaScript
var vocales = [‚Äúa‚Äù, ‚Äúe‚Äù, ‚Äúi‚Äù, ‚Äúo‚Äù, ‚Äúu‚Äù]; 
var numeroVocales = vocales.length; // numeroVocales = 5 
```

- **concat()**, se emplea para concatenar los elementos de varios arrays 


```JavaScript
var array1 = [1, 2, 3]; 
array2 = array1.concat(4, 5, 6); // array2 = [1, 2, 3, 4, 5, 6] 
array3 = array1.concat([4, 5, 6]); // array3 = [1, 2, 3, 4, 5, 6] 
```


- **join(separador)**, es la funci√≥n contraria a split(). Une todos los elementos de un array para  formar una cadena de texto. Para unir los elementos se utiliza el car√°cter separador indicado 

```JavaScript
var array = [‚Äúhola‚Äù, ‚Äúmundo‚Äù]; 
var mensaje = array.join(‚Äú‚Äù); // mensaje = ‚Äúholamundo‚Äù 
mensaje = array.join(‚Äù ‚Äú); // mensaje = ‚Äúhola mundo‚Äù
```


- **pop()**, elimina el √∫ltimo elemento del array y lo devuelve. El array original se modifica y su  longitud disminuye en 1 elemento. 


```JavaScript
var array = [1, 2, 3]; 
var ultimo = array.pop(); 
// ahora array = [1, 2], ultimo = 3 
```

- **push()**, a√±ade un elemento al final del array. El array original se modifica y aumenta su  longitud en 1 elemento. (Tambi√©n es posible a√±adir m√°s de un elemento a la vez) 


```JavaScript
var array = [1, 2, 3]; 
array.push(4); 
// ahora array = [1, 2, 3, 4] 
```


- **shift()**, elimina el primer elemento del array y lo devuelve. El array original se ve  modificado y su longitud disminuida en 1 elemento. 


```JavaScript
var array = [1, 2, 3]; 
var primero = array.shift(); 
// ahora array = [2, 3], primero = 1
```


- **unshift()**, a√±ade un elemento al principio del array. El array original se modifica y aumenta  su longitud en 1 elemento. (Tambi√©n es posible a√±adir m√°s de un elemento a la vez) 


```JavaScript
var array = [1, 2, 3]; 
array.unshift(0); 
// ahora array = [0, 1, 2, 3] 
```


- **reverse()**, modifica un array colocando sus elementos en el orden inverso a su posici√≥n  original: 


```JavaScript
var array = [1, 2, 3]; 
array.reverse(); 
// ahora array = [3, 2, 1]
```


#### Funciones √∫tiles para N√∫meros 

A continuaci√≥n se muestran algunas de las funciones y propiedades m√°s √∫tiles para el  manejo de n√∫meros. 

- **NaN**, (del ingl√©s, ‚ÄúNot a Number‚Äù) JavaScript emplea el valor NaN para indicar un valor  num√©rico no definido (por ejemplo, la divisi√≥n 0/0). 


```JavaScript
var numero1 = 0; 
var numero2 = 0; 
alert(numero1/numero2); // se muestra el valor NaN 
```


- **isNaN()**, permite proteger a la aplicaci√≥n de posibles valores num√©ricos no definidos var numero1 = 0; 

```JavaScript
var numero2 = 0; 

if(isNaN(numero1/numero2)) { 
 alert(‚ÄúLa divisi√≥n no est√° definida para los n√∫meros indicados‚Äù); 
} else { 
 alert(‚ÄúLa divisi√≥n es igual a => ‚Äù + numero1/numero2); 
}
```


- **Infinity**, hace referencia a un valor num√©rico infinito y positivo (tambi√©n existe el valor ‚Äì Infinity para los infinitos negativos) 

```JavaScript
var numero1 = 10; 
var numero2 = 0; 
alert(numero1/numero2); // se muestra el valor Infinity 
```


- **toFixed(digitos)**, devuelve el n√∫mero original con tantos decimales como los indicados por  el par√°metro digitos y realiza los redondeos necesarios. Se trata de una funci√≥n muy √∫til  por ejemplo para mostrar precios. 

```JavaScript
var numero1 = 4564.34567; 
numero1.toFixed(2); // 4564.35 
numero1.toFixed(6); // 4564.345670 
numero1.toFixed(); // 4564
```


#### Sentencia break/continue y otras estructuras de control 

La estructura de control for es muy sencilla de utilizar, pero tiene el inconveniente de que  el n√∫mero de repeticiones que se realizan s√≥lo se pueden controlar mediante las variables  definidas en la zona de actualizaci√≥n del bucle. 

Las sentencias break y continue permiten manipular el comportamiento normal de los  bucles for para detener el bucle o para saltarse algunas repeticiones. Concretamente, la  sentencia break permite terminar de forma abrupta un bucle y la  

sentencia continue permite saltarse algunas repeticiones del bucle. 

El siguiente ejemplo muestra el uso de la sentencia break: 


```JavaScript
var cadena = ‚ÄúEn un lugar de la Mancha de cuyo nombre no quiero acordarme‚Ä¶‚Äù; 
var letras = cadena.split(‚Äú‚Äù); 
var resultado = ‚Äú‚Äù; 

for(i in letras) { 
 if(letras[i] == ‚Äòa‚Äô) { 
 break; 
}  else { 
 resultado += letras[i]; 
 } 
} 

alert(resultado); // muestra ‚ÄúEn un lug‚Äù
```


Si el programa llega a una instrucci√≥n de tipo break;, sale inmediatamente del bucle y  contin√∫a ejecutando el resto de instrucciones que se encuentran fuera del bucle for. En el  ejemplo anterior, se recorren todas las letras de una cadena de texto y cuando se  encuentra con la primera letra ‚Äúa‚Äù, se detiene la ejecuci√≥n del bucle for. 

La utilidad de break es terminar la ejecuci√≥n del bucle cuando una variable toma un  determinado valor o cuando se cumple alguna condici√≥n. 

En ocasiones, lo que se desea es saltarse alguna repetici√≥n del bucle cuando se dan  algunas condiciones. Siguiendo con el ejemplo anterior, ahora se desea que el texto de  salida elimine todas las letras ‚Äúa‚Äù de la cadena de texto original: 


```JavaScript
var cadena = ‚ÄúEn un lugar de la Mancha de cuyo nombre no quiero acordarme‚Ä¶‚Äù; 
var letras = cadena.split(‚Äú‚Äù); 
var resultado = ‚Äú‚Äù; 

for(i in letras) { 
 if(letras[i] == ‚Äòa‚Äô) { 
 continue; 
}  else { 
 resultado += letras[i]; 
 } 
} 

alert(resultado); // muestra ‚ÄúEn un lugr de l Mnch de cuyo nombre no quiero cordrme‚Ä¶‚Äù
```

En este caso, cuando se encuentra una letra ‚Äúa‚Äù no se termina el bucle, sino que no se  ejecutan las instrucciones de esa repetici√≥n y se pasa directamente a la siguiente  repetici√≥n del bucle for. 

La utilidad de continue es que permite utilizar el bucle for para filtrar los resultados en  funci√≥n de algunas condiciones o cuando el valor de alguna variable coincide con un valor  determinado. 



#### Bucles 

Las estructuras de control de flujo que se han visto (if, else, for) y las sentencias que  modifican su comportamiento (break, continue) no son suficientes para realizar algunas  tareas complejas y otro tipo de repeticiones. Por ese motivo, JavaScript proporciona otras  estructuras de control de flujo diferentes y en algunos casos m√°s eficientes. 

#### Estructura While 

La estructura while permite crear bucles que se ejecutan ninguna o m√°s veces,  dependiendo de la condici√≥n indicada. Su definici√≥n formal es: 


```
while(condicion) { 
 ‚Ä¶ 
} 
```

El funcionamiento del bucle while se resume en: ‚Äúmientras se cumpla la condici√≥n  indicada, repite indefinidamente las instrucciones incluidas dentro del bucle‚Äù. 

Si la condici√≥n no se cumple ni siquiera la primera vez, el bucle no se ejecuta. Si la  condici√≥n se cumple, se ejecutan las instrucciones una vez y se vuelve a comprobar la  condici√≥n. Si se sigue cumpliendo la condici√≥n, se vuelve a ejecutar el bucle y as√≠ se  contin√∫a hasta que la condici√≥n no se cumpla. 

Evidentemente, las variables que controlan la condici√≥n deben modificarse dentro del  propio bucle, ya que de otra forma, la condici√≥n se cumplir√≠a siempre y el bucle while se  repetir√≠a indefinidamente.

El siguiente ejemplo utiliza el bucle while para sumar todos los n√∫meros menores o  iguales que otro n√∫mero: 


```JavaScript
var resultado = 0; 
var numero = 100; 
var i = 0; 

while(i <= numero) { 
 resultado += i; 
 i++; 
} 

alert(resultado); 
```

El programa debe sumar todos los n√∫meros menores o igual que otro dado. Por ejemplo si  el n√∫mero es 5, se debe calcular: 1 + 2 + 3 + 4 + 5 = 15 

Este tipo de condiciones ‚Äúsuma n√∫meros mientras sean menores o iguales que otro  n√∫mero dado‚Äù) se resuelven muy f√°cilmente con los bucles tipo while, aunque tambi√©n se  pod√≠an resolver con bucles de tipo for. 

En el ejemplo anterior, mientras se cumpla la condici√≥n, es decir, mientras que la  variable i sea menor o igual que la variable numero, se ejecutan las instrucciones del  bucle. 

Dentro del bucle se suma el valor de la variable i al resultado total (variable resultado) y se  actualiza el valor de la variable i, que es la que controla la condici√≥n del bucle. Si no se  actualiza el valor de la variable i, la ejecuci√≥n del bucle continua infinitamente o hasta que  el navegador permita al usuario detener el script.



#### Estructura Do‚Ä¶while 

El bucle de tipo do‚Ä¶while es muy similar al bucle while, salvo que en este caso siempre se  ejecutan las instrucciones del bucle al menos la primera vez. Su definici√≥n formal es: 

```
do { 
 ‚Ä¶ 
} while(condicion); 
```


De esta forma, como la condici√≥n se comprueba despu√©s de cada repetici√≥n, la primera  vez siempre se ejecutan las instrucciones del bucle. Es importante no olvidar que despu√©s  del while() se debe a√±adir el car√°cter ; (al contrario de lo que sucede con el  bucle while simple). 

Utilizando este bucle se puede calcular f√°cilmente el factorial de un n√∫mero: 


```JavaScript
var resultado = 1; 
var numero = 5; 

do { 
 resultado *= numero; // resultado = resultado * numero 
 numero‚Äì; 
} while(numero > 0); 

alert(resultado);
```


En el c√≥digo anterior, el resultado se multiplica en cada repetici√≥n por el valor de la  variable numero. Adem√°s, en cada repetici√≥n se decrementa el valor de esta  variable numero. La condici√≥n del bucle do‚Ä¶while es que el valor de numero sea mayor  que 0, ya que el factorial de un n√∫mero multiplica todos los n√∫meros menores o iguales  que √©l mismo, pero hasta el n√∫mero 1 (el factorial de 5 por ejemplo es 5 x 4 x 3 x 2 x 1 =  120). 

Como en cada repetici√≥n se decrementa el valor de la variable numero y la condici√≥n es  que numero sea mayor que cero, en la repetici√≥n en la que numero valga 0, la condici√≥n  ya no se cumple y el programa se sale del bucle do‚Ä¶while. 



#### Estructura Switch 

La estructura if‚Ä¶else se puede utilizar para realizar comprobaciones m√∫ltiples y tomar  decisiones complejas. Sin embargo, si todas las condiciones dependen siempre de la  misma variable, el c√≥digo JavaScript resultante es demasiado redundante: 

```
if(numero == 5) { 
 ‚Ä¶ 
}  else if(numero == 8) { 
 ‚Ä¶ 
}  else if(numero == 20) { 
 ‚Ä¶ 
} ‚Ä¶
```


En estos casos, la estructura switch es la m√°s eficiente, ya que est√° especialmente  dise√±ada para manejar de forma sencilla m√∫ltiples condiciones sobre la misma variable. Su  definici√≥n formal puede parecer compleja, aunque su uso es muy sencillo: 

```
switch(variable) { 
 case valor_1: 
    ‚Ä¶ 
    break; 

 case valor_2: 
    ‚Ä¶ 
    break; 
 ‚Ä¶ 
 case valor_n: 
    ‚Ä¶ 
    break; 

 default: 
   ‚Ä¶ 
   break; 
}
```
El anterior ejemplo realizado con if‚Ä¶else se puede rehacer mediante switch: switch(numero) { 


```
 case 5: 
   ‚Ä¶ 
   break; 
 case 8: 
   ‚Ä¶ 
   break; 
 case 20: 
   ‚Ä¶ 
   break; 
 default: 
   ‚Ä¶ 
   break; 
}
```

La estructura switch se define mediante la palabra reservada switch seguida, entre  par√©ntesis, del nombre de la variable que se va a utilizar en las comparaciones. Como es  habitual, las instrucciones que forman parte del switch se encierran entre las llaves { y }. 

Dentro del switch se definen todas las comparaciones que se quieren realizar sobre el  valor de la variable. Cada comparaci√≥n se indica mediante la palabra  reservada case seguida del valor con el que se realiza la comparaci√≥n. Si el valor de la  variable utilizada por switch coincide con el valor indicado por case, se ejecutan las  instrucciones definidas dentro de ese case. 

Normalmente, despu√©s de las instrucciones de cada case se incluye la  sentencia break para terminar la ejecuci√≥n del switch, aunque no es obligatorio. Las  comparaciones se realizan por orden, desde el primer case hasta el √∫ltimo, por lo que es  muy importante el orden en el que se definen los case. 

¬øQu√© sucede si ning√∫n valor de la variable del switch coincide con los valores definidos en  los case? En este caso, se utiliza el valor default para indicar las instrucciones que se  ejecutan en el caso en el que ning√∫n case se cumpla para la variable indicada. 

Aunque default es opcional, las estructuras switch suelen incluirlo para definir al menos  un valor por defecto para alguna variable o para mostrar alg√∫n mensaje por pantalla.

---
---
